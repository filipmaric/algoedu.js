/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Graph"] = factory();
	else
		root["Graph"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./components/colors.js":
/*!******************************!*\
  !*** ./components/colors.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getOpacity: () => (/* binding */ getOpacity),\n/* harmony export */   hsvColor: () => (/* binding */ hsvColor),\n/* harmony export */   parseRGB: () => (/* binding */ parseRGB),\n/* harmony export */   rgb2hsv: () => (/* binding */ rgb2hsv),\n/* harmony export */   rgbColor: () => (/* binding */ rgbColor),\n/* harmony export */   setOpacity: () => (/* binding */ setOpacity)\n/* harmony export */ });\nconst ctx = document.createElement(\"canvas\").getContext(\"2d\");\n\n// input: r,g,b in [0,1], out: h in [0,360) and s,v in [0,1]\nfunction rgb2hsv(r, g, b) {\n    let v=Math.max(r,g,b), c=v-Math.min(r,g,b);\n    let h= c && ((v==r) ? (g-b)/c : ((v==g) ? 2+(b-r)/c : 4+(r-g)/c)); \n    return [60*(h<0?h+6:h), v&&c/v, v];\n}\n\n// read RGB from rgb or rgba string\nfunction parseRGB(str) {\n    const m = str.match(/^rgba?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*(\\d+([.]\\d*)?))?\\s*\\)$/i);\n    return m ? {\n        r: parseFloat(m[1]),\n        g: parseFloat(m[2]),\n        b: parseFloat(m[3])\n    } : null;\n}\n\n// convert color in any format to rgb\nfunction rgbColor(str){\n    function hexToRGB(hex) {\n        const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n        return result ? {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16)\n        } : null;\n    }\n\n    ctx.fillStyle = str;\n    const color = ctx.fillStyle;\n    if (color[0] == '#')\n        return hexToRGB(color);\n    else\n        return parseRGB(color);\n}\n\nfunction hsvColor(str) {\n    const rgb = rgbColor(str);\n    const hsv = rgb2hsv(rgb.r / 255, rgb.g / 255, rgb.b / 255);\n    return {h: hsv[0], s: hsv[1], v: hsv[2]};\n}\n\n// extract opacity from color string\nfunction getOpacity(color) {\n    const defaultOpacity = 1;\n    \n    if (!color)\n        return defaultOpacity;\n    const m = color.match(/^rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+([.]\\d*)?)\\s*\\)$/i);\n    return parseFloat(m ? m[4] : defaultOpacity);\n}\n\n// set opacity to color string\nfunction setOpacity(color, o) {\n    const rgb = rgbColor(color);\n    return \"rgba(\" + rgb.r + \", \" + rgb.g + \", \" + rgb.b + \", \" + o + \")\";\n}\n\n\n//# sourceURL=webpack://algoedu.js/./components/colors.js?");

/***/ }),

/***/ "./components/commands.js":
/*!********************************!*\
  !*** ./components/commands.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommandSetElementContent: () => (/* binding */ CommandSetElementContent),\n/* harmony export */   Commands: () => (/* binding */ Commands)\n/* harmony export */ });\nclass Commands {\n    constructor(commands) {\n        this.commands = commands;\n        this.current = 0;\n    }\n\n    get length() {\n        return this.commands.length;\n    }\n\n    reset() {\n        while (this.inProgress()) {\n            this.current--;\n            this.undoCurrentCommand();\n        }\n    }\n\n    inProgress() {\n        return this.current > 0;\n    }\n\n    done() {\n        return this.current >= this.commands.length;\n    }\n\n    next(quick=false) {\n        if (this.done())\n            return false;\n        this.doCurrentCommand(quick);\n        this.current++;\n        return true;\n    }\n\n    doCurrentCommand(quick=false) {\n        if (Array.isArray(this.commands[this.current]))\n            this.commands[this.current].forEach(command => command.doCommand(quick));\n        else\n            this.commands[this.current].doCommand(quick);\n    }\n\n    undoCurrentCommand(quick=false) {\n        if (Array.isArray(this.commands[this.current]))\n            this.commands[this.current].slice().reverse().forEach(command => command.undoCommand(quick));\n        else\n            this.commands[this.current].undoCommand(quick);\n    }\n\n    previous(quick=false) {\n        if (this.current == 0)\n            return false;\n        --this.current;\n        this.undoCurrentCommand(quick);\n        return true;\n    }\n\n    run() {\n        while (!this.done()) {\n            this.doCurrentCommand();\n            this.current++;\n        }\n    }\n\n    gotoCommand(k) {\n        if (this.current < k) {\n            while (this.next(this.current < k - 1) && this.current < k);\n        } else if (this.current > k) {\n            while (this.previous(this.current > k + 1) && this.current > k);\n        }\n    }\n}\n\nclass CommandSetElementContent {\n    constructor(element, content) {\n        this.element = element;\n        this.content = content;\n    }\n\n    doCommand() {\n        this.oldContent = this.element.innerHTML;\n        this.element.innerHTML = this.content;\n    }\n\n    undoCommand() {\n        this.element.innerHTML = this.oldContent;\n    }\n}\n\n\n\n\n//# sourceURL=webpack://algoedu.js/./components/commands.js?");

/***/ }),

/***/ "./components/graph.js":
/*!*****************************!*\
  !*** ./components/graph.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BinaryTree: () => (/* binding */ BinaryTree),\n/* harmony export */   CommandResetAllVertexCSS: () => (/* binding */ CommandResetAllVertexCSS),\n/* harmony export */   CommandSetEdgeCSS: () => (/* binding */ CommandSetEdgeCSS),\n/* harmony export */   CommandSetVertexCSS: () => (/* binding */ CommandSetVertexCSS),\n/* harmony export */   CommandSetVertexContent: () => (/* binding */ CommandSetVertexContent),\n/* harmony export */   CommandSetVertexLabel: () => (/* binding */ CommandSetVertexLabel),\n/* harmony export */   Graph: () => (/* binding */ Graph),\n/* harmony export */   GraphCommands: () => (/* binding */ GraphCommands),\n/* harmony export */   GraphDrawing: () => (/* binding */ GraphDrawing),\n/* harmony export */   WeightedGraph: () => (/* binding */ WeightedGraph)\n/* harmony export */ });\n/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colors.js */ \"./components/colors.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./components/util.js\");\n/* harmony import */ var _union_find_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./union_find.js */ \"./components/union_find.js\");\n/* harmony import */ var _commands_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./commands.js */ \"./components/commands.js\");\n\n\n\n\nfunction distance(ax, ay, bx, by) { \n    return Math.sqrt((ax - bx)*(ax - bx) + (ay - by)*(ay - by));\n}\n\nclass Graph {\n    constructor(directed=true, n=0) {\n        this.directed = directed;\n        this.weighted = false;\n        this.emptyGraph(n);\n    }\n\n    static directed(n=0) {\n        return new Graph(true, n);\n    }\n\n    static undirected(n=0) {\n        return new Graph(false, n);\n    }\n    \n    numVertices() {\n        return this.neighbours.length;\n    }\n\n    numEdges() {\n        return this.getEdges().length;\n    }\n\n    getVertices() {\n        return Array.from({ length: this.numVertices()}, (_, index) => index);\n    }\n\n    addVertex() {\n        this.neighbours.push([]);\n        return this.numVertices() - 1;\n    }\n\n    addEdge(i, j) {\n        this.neighbours[i].push(j);\n        if (!this.directed)\n            this.neighbours[j].push(i);\n    }\n\n    removeEdge(i, j) {\n        this.neighbours[i] = this.neighbours[i].filter(item => item != j);\n        if (!this.directed)\n            this.neighbours[j] = this.neighbours[j].filter(item => item != i);\n    }\n\n    hasEdge(i, j) {\n        return this.neighbours[i].includes(j);\n    }\n\n    addEdges(edges) {\n        edges.forEach(edge => this.addEdge(...edge));\n    }\n\n    addEdgesStr(edges) {\n        function toNumber(input) {\n            if (/^\\d+$/.test(input)) {\n                return parseInt(input);\n            } else if (/^[A-Z]$/.test(input)) {\n                return input.charCodeAt(0) - 'A'.charCodeAt(0);\n            }\n        }\n        const pairs = edges.split(',').map(pair => pair.split('-'));\n        for (const pair of pairs) {\n            const [from, to] = pair;\n            this.addEdge(toNumber(from), toNumber(to));\n        }\n    }\n\n    getEdges() {\n        if (this.directed)\n            return this.neighbours.map((ns, v) => ns.map(n => [v, n])).flat(1);\n        else\n            return this.neighbours.map((ns, v) => ns.map(n => [v, n])).flat(1).filter(edge => edge[0] <= edge[1]);\n    }\n\n    // in undirected graphs, edges are sorted, and in directed graphs edges are unchanged\n    normalizeEdge(edge) {\n        if (!this.directed && edge[0] > edge[1])\n            return [edge[1], edge[0]];\n        return edge;\n    }\n\n    getNeighbours(i) {\n        return this.neighbours[i];\n    }\n\n    sortNeighbours() {\n        for (let i = 0; i < this.neighbours.length; i++)\n            this.neighbours[i].sort((a, b) => a-b);\n    }\n\n    degree() {\n        return this.neighbours.map(n => n.length);\n    }\n\n    outdegree() {\n        return this.neighbours.map(n => n.length);\n    }\n\n    indegree() {\n        const indeg = new Array(this.numVertices()).fill(0);\n        this.neighbours.forEach(n => n.forEach(v => indeg[v]++));\n        return indeg;\n    }\n\n    // GENERATING GRAPHS\n\n    // graph with no edges\n    emptyGraph(n) {\n        this.neighbours = Array.from({length: n}, () => []);\n    }\n\n    // all edges of a full graph (without loops)\n    static fullGraphEdges(n, directed=false) {\n        const edges = [];\n        for (let i = 0; i < n; i++)\n            for (let j = 0; j < n; j++) {\n                if (i == j) continue;\n                if (i < j || directed)\n                    edges.push([i, j]);\n            }\n        return edges;\n    }\n\n    // full graph with all possible edges\n    fullGraph(numVertices) {\n        if (numVertices === undefined)\n            numVertices = this.numVertices();\n        this.emptyGraph(numVertices);\n        this.addEdges(Graph.fullGraphEdges(numVertices, this.directed));\n        this.sortNeighbours();\n    }\n\n    // random graph with numVertices vertices, numEdges edges and\n    // edges chosen from a given set of edges\n    randomSubgraph(numVertices, numEdges, edges) {\n        this.emptyGraph(numVertices);\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.shuffle)(edges);\n        this.addEdges(edges.slice(0, numEdges));\n        this.sortNeighbours();\n    }\n\n    // random graph with numVertices vertices and numEdges edges\n    randomGraph(numVertices, numEdges) {\n        const edges = Graph.fullGraphEdges(numVertices, this.directed);\n        this.randomSubgraph(numVertices, numEdges, edges);\n    }\n\n    // random graph with numComponents connected components where\n    // each component has between 1 and maxComponent vertices\n    randomDisconnectedGraph(numComponents, maxComponent) {\n        const card = new Array(numComponents);\n        for (let i = 0; i < numComponents; i++)\n            card[i] = 1 + (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.random)(maxComponent - 1);\n        let prefixSums = new Array(numComponents+1);\n        prefixSums[0] = 0;\n        for (let i = 1; i <= numComponents; i++)\n            prefixSums[i] = prefixSums[i-1] + card[i-1];\n        const numVertices = prefixSums[prefixSums.length - 1];\n        this.emptyGraph(numVertices);\n        const vertices = Array.from({ length: numVertices}, (_, index) => index);\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.shuffle)(vertices);\n        for (let c = 0; c < numComponents; c++) {\n            const n = card[c];\n            const component = new Graph(false);\n            component.randomConnectedGraph(n, (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.random)(n-1, 2*n));\n            for (const edge of component.getEdges()) {\n                const [from, to] = edge;\n                this.addEdge(vertices[prefixSums[c] + from], vertices[prefixSums[c] + to]);\n            }\n        }\n    }\n    \n    // random tree edges with numVertices vertices and edges chosen from the given set of edges\n    static randomSubtree(numVertices, edges) {\n        const treeEdges = [];\n        const unionFind = new _union_find_js__WEBPACK_IMPORTED_MODULE_2__.UnionFind(numVertices);\n\n        if (edges === undefined)\n            edges = Graph.fullGraphEdges(numVertices, false);\n\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.shuffle)(edges);\n\n        for (const [nodeA, nodeB] of edges) {\n            if (unionFind.union(nodeA, nodeB))\n                treeEdges.push([nodeA, nodeB]);\n            if (treeEdges.length == numVertices - 1)\n                break;\n        }\n        return treeEdges;\n    }\n\n    // orient edges of a tree from its root to its leaves\n    static orientTreeEdges(edges, root) {\n        function dfs(node) {\n            visited.push(node);\n            const nodeEdges = edges.filter(edge => edge.includes(node));\n            const neighbours = nodeEdges.map(edge => edge.filter(x => x != node)).flat(1);\n            neighbours.forEach(neighbour => {\n                if (!visited.includes(neighbour)) {\n                    orientedEdges.push([node, neighbour]);\n                    dfs(neighbour);\n                }\n            });\n        }\n        const visited = [];\n        const orientedEdges = [];\n        dfs(root);\n        return orientedEdges;\n    }\n\n    \n    // random connected graph with numVertices vertices, numEdges\n    // edges, and edges chosen from a given list of edges\n    randomConnectedSubgraph(numVertices, numEdges, edges) {\n        this.emptyGraph(numVertices);\n        const treeEdges = Graph.orientTreeEdges(Graph.randomSubtree(numVertices, edges), 0);\n        const remainingEdges = edges.filter(edge => !treeEdges.some(edge1 => Graph.equalEdges(edge, edge1, false)));\n        this.addEdges(treeEdges);\n        this.addEdges(remainingEdges.slice(0, numEdges - treeEdges.length));\n        this.sortNeighbours();\n    }\n\n    // random connected graph with numVertices vertices and numEdges edges\n    randomConnectedGraph(numVertices, numEdges) {\n        const allEdges = Graph.fullGraphEdges(numVertices, false);\n        this.randomConnectedSubgraph(numVertices, numEdges, allEdges);\n    }\n\n    // random DAG (directed acyclic graph) with numVertices vertices and numEdges edges\n    randomDAG(numVertices, numEdges) {\n        this.emptyGraph(numVertices);\n        const vertices = Array.from({ length: numVertices - 1}, (_, index) => index + 1);\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.shuffle)(vertices);\n        vertices.unshift(0);\n        let i = 0;\n        while (i < numEdges) {\n            let source, target;\n            source = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.random)(numVertices - 2);\n            target = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.random)(source + 1, numVertices - 1);\n            if (!this.hasEdge(vertices[source], vertices[target])) {\n                this.addEdge(vertices[source], vertices[target]);\n                i++;\n            }\n        }\n    }\n\n    // random connected DAG (directed acyclic graph) with numVertices vertices and numEdges edges\n    randomConnectedDAG(numVertices, numEdges) {\n        this.emptyGraph(numVertices);\n        const tree = Graph.directed(numVertices);\n        const treeEdges = Graph.orientTreeEdges(Graph.randomSubtree(this.numVertices()), 0);\n        tree.addEdges(treeEdges);\n        this.addEdges(treeEdges);\n\n        const preorder = tree.dfsPreorderNumeration(0);\n        const vertices = new Array(numVertices);\n        for (let i = 0; i < numVertices; i++)\n            vertices[preorder[i]] = i;\n        \n        let i = 0;\n        while (i <= numEdges - numVertices) {\n            let source, target;\n            source = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.random)(numVertices - 2);\n            target = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.random)(source + 1, numVertices - 1);\n            if (!this.hasEdge(vertices[source], vertices[target])) {\n                this.addEdge(vertices[source], vertices[target]);\n                i++;\n            }\n        }\n    }\n\n    // random Euler graph (a graph that has an Euler path)\n    randomEulerGraph(numVertices) {\n        this.emptyGraph(numVertices);\n        const visited = new Array(numVertices).fill(false);\n        let numVisited = 0;\n        let prev = 0;\n        visited[prev] = 0;\n        while(true) {\n            const next = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.random)(0, numVertices - 1);\n            if (next == prev) continue;\n            if (this.hasEdge(prev, next) ||\n                this.hasEdge(next, prev))\n                continue;\n            this.addEdge(prev, next);\n            if (!visited[next]) {\n                visited[next] = true;\n                numVisited++;\n            }\n            prev = next;\n            if (numVisited == numVertices) {\n                if (prev != 0)\n                    this.addEdge(prev, 0);\n                break;\n            }\n        }\n    }\n\n\n    // all edges of m by n lattice graph\n    static latticeGraphEdges(m, n, diagonals) {\n        function vertex(i, j) {\n            return i * n + j;\n        }\n\n        const edges = [];\n\n        for (let i = 0; i < m; i++)\n            for (let j = 1; j < n; j++) {\n                const edge = [vertex(i, j-1), vertex(i, j)];\n                edges.push(edge);\n            }\n\n        for (let j = 0; j < n; j++)\n            for (let i = 1; i < m; i++) {\n                const edge = [vertex(i-1, j), vertex(i, j)];\n                edges.push(edge);\n            }\n\n        if (diagonals) {\n            for (let i = 1; i < m; i++)\n                for (let j = 1; j < n; j++) {\n                    const edge = [vertex(i-1, j-1), vertex(i, j)];\n                    edges.push(edge);\n                }\n\n            for (let i = 0; i < m-1; i++)\n                for (let j = 1; j < n; j++) {\n                    const edge = [vertex(i, j), vertex(i+1, j-1)];\n                    edges.push(edge);\n                }\n        }\n        return edges;\n    }\n\n    // full m by n lattice graph\n    latticeGraph(m, n, diagonals=false) {\n        this.emptyGraph(m * n);\n        const edges = Graph.latticeGraphEdges(m, n, diagonals);\n        this.addEdges(edges);\n        this.sortNeighbours();\n    }\n\n    // a random subgraph of m by n lattice graph with numEdges edges\n    randomLatticeGraph(m, n, numEdges, diagonals=true) {\n        const edges = Graph.latticeGraphEdges(m, n, diagonals);\n        this.randomSubgraph(m * n, numEdges, edges);\n    }\n\n    // a random connected random subgraph of m by n lattice graph with numEdges edges\n    randomConnectedLatticeGraph(m, n, numEdges, diagonals=true) {\n        const edges = Graph.latticeGraphEdges(m, n, diagonals);\n        this.randomConnectedSubgraph(m * n, numEdges, edges);\n    }\n\n    // a random strongly connected graph\n    randomStronglyConnected(numVertices, numEdges) {\n        this.emptyGraph(numVertices);\n        const vertices = Array.from({ length: numVertices }, (_, index) => index);\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.shuffle)(vertices);\n        let currentNumEdges;\n        if (numVertices > 1) {\n            for (let i = 0; i < numVertices - 1; i++)\n                this.addEdge(vertices[i], vertices[i+1]);\n            currentNumEdges = numVertices - 1;\n            let from = numVertices - 1, to;\n            while (true) {\n                if (currentNumEdges >= numEdges - 1) \n                    to = 0;\n                else\n                    to = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.random)(0, from-1);\n                this.addEdge(vertices[from], vertices[to]);\n                currentNumEdges++;\n                if (to == 0) break;\n                from = to;\n            }\n        }\n        while (currentNumEdges < numEdges) {\n            const source = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.random)(numVertices - 1);\n            const target = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.random)(numVertices - 1);\n            if (source == target) continue;\n            if (this.hasEdge(vertices[source], vertices[target]) ||\n                this.hasEdge(vertices[target], vertices[source]))\n                continue;\n            this.addEdge(vertices[source], vertices[target]);\n            currentNumEdges++;\n        }\n    }\n    \n    \n    // graph for ilustrating Tarjan's SCC algorithm\n    // it has numComponents strongly connected components (SCC) where each SCC\n    // contains between 1 and maxComponent vertices\n    randomTarjanSCC(numComponents, maxComponent=4, maxIntercomponentEdges=3) {\n        // condensed DAG of a graph (graph connecting its sccs)\n        const dag = Graph.directed();\n        dag.randomConnectedDAG(numComponents, Math.min(2*numComponents, numComponents*(numComponents-1)/2));\n        // number of vertices in each component\n        const card = new Array(numComponents);\n        for (let i = 0; i < numComponents; i++)\n            card[i] = 1 + (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.random)(maxComponent - 1);\n        // prefix sums of card array - usefull for calculating vertex indices\n        let prefixSums = new Array(numComponents+1);\n        prefixSums[0] = 0;\n        for (let i = 1; i <= numComponents; i++)\n            prefixSums[i] = prefixSums[i-1] + card[i-1];\n\n        // number of vertices of the final graph\n        const numVertices = prefixSums[prefixSums.length - 1];\n        this.emptyGraph(numVertices);\n\n        // permutation of vertices\n        const vertices = Array.from({ length: numVertices - 1}, (_, index) => index + 1);\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.shuffle)(vertices);\n        vertices.unshift(0);\n\n        // generate each scc\n        for (let c = 0; c < numComponents; c++) {\n            const component = Graph.directed();\n            // number of vertices and edges in the scc\n            const n = card[c];\n            const m = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.random)(n, Math.min(Math.floor(1.5*n), n*(n - 1)/2));\n            // generate scc and add it to the graph\n            component.randomStronglyConnected(n, m);\n            for (const edge of component.getEdges()) {\n                const [from, to] = edge;\n                this.addEdge(vertices[prefixSums[c] + from], vertices[prefixSums[c] + to]);\n            }\n        }\n        // connect sccs\n        for (const edge of dag.getEdges()) {\n            const [from, to] = edge;\n            // multiply each inter scc edge num times\n            let num = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.random)(1, maxIntercomponentEdges);\n            for (let i = 0; i < num; i++) {\n                const from1 = vertices[prefixSums[from] + (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.random)(card[from] - 1)];\n                const to1 = vertices[prefixSums[to] + (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.random)(card[to] - 1)];\n                if (!this.hasEdge(from1, to1))\n                    this.addEdge(from1, to1);\n            }\n        }\n    }\n\n\n    // ALGORITHMS\n\n    dfsPrePost(startVertex, preprocess, postprocess) {\n        function dfsRecPrePost(vertex) {\n            if (visited[vertex])\n                return;\n            visited[vertex] = true;\n            preprocess(vertex);\n            this.neighbours[vertex].forEach(neighbour => {\n                if (neighbour != null && !visited[neighbour])\n                    this.dfsRec(neighbour, visited, trace);\n            });\n            postprocess(vertex);\n        }\n        const visited = new Array(this.numVertices()).fill(false);\n        dfsRecPrePost(startVertex);\n    }\n\n    dfsRec(vertex, visited, trace) {\n        if (visited[vertex])\n            return;\n        visited[vertex] = true;\n        this.neighbours[vertex].forEach(neighbour => {\n            if (neighbour != null && !visited[neighbour]) {\n                trace.push([vertex, neighbour]);\n                this.dfsRec(neighbour, visited, trace);\n                trace.push([vertex]);\n            }\n        });\n    }\n\n    dfs(vertex=0, visited=undefined) {\n        if (visited === undefined)\n            visited = new Array(this.numVertices()).fill(false);\n        const trace = []\n        this.dfsRec(vertex, visited, trace);\n        return trace;\n    }\n\n    dfsTree(vertex=0, visited=undefined) {\n        return this.dfs(vertex, visited).filter(item => item.length == 2);\n    }\n    \n\n    dfsParent(vertex=0, visited=undefined) {\n        const parent = new Array(this.numVertices()).fill(-1);\n        this.dfsTree(vertex, visited).forEach(edge => {\n            const [from, to] = edge;\n            parent[to] = from;\n        });\n        return parent;\n    }\n\n    dfsOrder(vertex=0, visited=undefined) {\n        const treeEdges = this.dfsTree(vertex, visited);\n        if (treeEdges.length == 0)\n            return [vertex];\n        let order = treeEdges.map(edge => edge[1]);\n        order.unshift(treeEdges[0][0]);\n        return order;\n    }\n    \n    dfsForrest(roots) {\n        const visited = new Array(this.numVertices()).fill(false);\n        const trace = [];\n        if (roots === undefined) {\n            for (let i = 0; i < this.numVertices(); i++)\n                if (!visited[i])\n                    this.dfsRec(i, visited, trace);\n        } else {\n            roots.forEach(i => {\n                if (!visited[i])\n                    this.dfsRec(i, visited, trace);\n            });\n        }\n        return trace.filter(item => item.length == 2);\n    }\n\n    dfsPreorderNumeration(vertex=0, visited=undefined) {\n        const dfsTrace = this.dfs(vertex, visited);\n        const preorder = new Array(this.numVertices()).fill(-1);\n        if (dfsTrace.length == 0) {\n            preorder[vertex] = 0;\n            return preorder;\n        }\n        let preorderNum = 0;\n        const start = dfsTrace[0][0];\n        preorder[start] = preorderNum++;\n        dfsTrace.forEach(data => {\n            if (data.length == 2) {\n                const [from, to] = data;\n                preorder[to] = preorderNum++;\n            }\n        });\n        return preorder;\n    }\n\n    dfsPostorderNumeration(vertex=0, visited=undefined) {\n        const dfsTrace = this.dfs(vertex, visited);\n        const postorder = new Array(this.numVertices()).fill(-1);\n        if (dfsTrace.length == 0)\n            return postorder;\n        let postorderNum = 0;\n        const start = dfsTrace[0][0];\n        const stack = [];\n        dfsTrace.forEach(data => {\n            if (data.length == 2) {\n                const [from, to] = data;\n                stack.push(to);\n            } else if (data.length == 1) {\n                const to = stack.pop();\n                postorder[to] = postorderNum++;\n            }\n        });\n        postorder[start] = postorderNum++;\n        return postorder;\n    }\n\n    \n    dfsLowlink(vertex = 0) {\n        if (this.directed)\n            return this.dfsLowlinkDirected(vertex);\n        else\n            return this.dfsLowlinkUndirected(vertex);\n    }\n    \n    dfsLowlinkUndirected(vertex = 0) {\n        const lowlink = new Array(this.numVertices()).fill(-1);\n        const parent = new Array(this.numVertices()).fill(-1);\n        let preorderNum = 0;\n        const preorder = new Array(this.numVertices()).fill(-1);\n        const order = [];\n\n        const self = this;\n        function dfsRec(vertex) {\n            order.push(vertex);\n            preorder[vertex] = lowlink[vertex] = preorderNum++;\n            self.neighbours[vertex].forEach(neighbour => {\n                if (preorder[neighbour] == -1) {\n                    parent[neighbour] = vertex;\n                    dfsRec(neighbour);\n                    if (lowlink[neighbour] < lowlink[vertex])\n                        lowlink[vertex] = lowlink[neighbour];\n                } else if (neighbour != parent[vertex]) {\n                    if (preorder[neighbour] < lowlink[vertex])\n                        lowlink[vertex] = preorder[neighbour];\n                }\n            });\n        }\n\n        dfsRec(vertex);\n        return lowlink.map(l => order[l]);\n    }\n\n    dfsLowlinkDirected(start = 0) {\n        return this.tarjan_scc()[1];\n    }\n\n    dfsEdgeClassification(start=0) {\n        const preOrder = this.dfsPreorderNumeration(start);\n        const postOrder = this.dfsPostorderNumeration(start);\n        const parent = this.dfsParent(start);\n        const edgeType = {};\n        this.getEdges().forEach(edge => {\n            const [v, w] = edge;\n            const edgeStr = JSON.stringify(edge);\n            if (preOrder[v] == -1 || postOrder[v] == -1 ||\n                preOrder[w] == -1 || postOrder[w] == -1)\n                return;\n\n            if (this.directed) {\n                if (parent[w] == v)\n                    edgeType[edgeStr] = 'treeEdge';\n                else if (postOrder[v] <= postOrder[w])\n                    edgeType[edgeStr] = 'backEdge';\n                else if (preOrder[v] > preOrder[w])\n                    edgeType[edgeStr] = 'crossEdge';\n                else\n                    edgeType[edgeStr] = 'directEdge';\n            } else {\n                if (parent[w] == v || parent[v] == w)\n                    edgeType[edgeStr] = 'treeEdge';\n                else\n                    edgeType[edgeStr] = 'backEdge';\n            }\n        });\n        return edgeType;\n    }\n\n    connected() {\n        return this.connectedComponents(0).every(c => c == 0);\n    }\n\n    bridges() {\n        if (this.directed)\n            throw \"Bridges are not yet implemented for directed graphs\";\n        const lowlink = graph.dfsLowlink(0);\n        const preorder = graph.dfsPreorderNumeration(0);\n        const bridges = this.dfsTree(0).filter(edge => {\n            const [from, to] = edge;\n            return preorder[from] < preorder[to] &&\n                   preorder[lowlink[to]] > preorder[from];\n        });\n        return bridges;\n    }\n\n    articulationPoints() {\n        if (this.directed)\n            throw \"Articulation points are not yet implemented for directed graphs\";\n        const aps = [];\n        const start = 0;\n        const lowlink = graph.dfsLowlink(start);\n        const preorder = graph.dfsPreorderNumeration(start);\n        const dfsTree = graph.dfsTree(start);\n        const treeNeighbours = Graph.adjacencyLists(this.numVertices(), dfsTree);\n        \n        for (let u = 1; u < this.numVertices(); u++) {\n            for (const v of treeNeighbours[u])\n                if (preorder[lowlink[v]] >= preorder[u]) {\n                    aps.push(u);\n                    break;\n                }\n        }\n\n        const startChildren = dfsTree.filter(edge => {\n            const [from, to] = edge;\n            return from == start;\n        });\n        \n        if (startChildren.length > 1)\n            aps.push(start);\n        return aps;\n    }\n\n    tarjan_scc() {\n        const component = new Array(this.numVertices()).fill(-1);\n        let componentNum = 0;\n        const stack = [];\n        const preOrder = new Array(this.numVertices()).fill(-1);\n        let preOrderNum = 0;\n        const lowlink = new Array(this.numVertices()).fill(-1);\n        const inStack = new Array(this.numVertices()).fill(false);\n        const self = this;\n        const order = [];\n        function dfs(v) {\n            order.push(v);\n            preOrder[v] = lowlink[v] = preOrderNum++;\n            stack.push(v); inStack[v] = true;\n            self.neighbours[v].forEach(n => {\n                if (preOrder[n] == -1) {\n                    dfs(n);\n                    lowlink[v] = Math.min(lowlink[v], lowlink[n]);\n                } else if (inStack[n])\n                    lowlink[v] = Math.min(lowlink[v], preOrder[n]);\n            });\n            if (lowlink[v] == preOrder[v]) {\n                let vv;\n                do {\n                    vv = stack.pop();\n                    inStack[vv] = false;\n                    component[vv] = componentNum;\n                } while (vv != v);\n                componentNum++;\n            }\n        }\n        for (let v = 0; v < this.numVertices(); v++)\n            if (preOrder[v] == -1)\n                dfs(v);\n        return [component, lowlink.map(v => order[v])];\n    }\n\n    stronglyConnectedComponents() {\n        return this.tarjan_scc()[0];\n    }\n\n    connectedComponents() {\n        const components = new Array(this.numVertices()).fill(-1);\n        let component = 0;\n        for (let v = 0; v < this.numVertices(); v++) {\n            if (components[v] == -1) {\n                this.dfsOrder(v).forEach(vertex => components[vertex] = component);\n                component++;\n            }\n        }\n        return components;\n    }\n    \n\n    topologicalSort() {\n        const order = [];\n        const indeg = this.indegree();\n        const queue = [];\n        for (let v = 0; v < this.numVertices(); v++)\n            if (indeg[v] == 0)\n                queue.push(v);\n        while (queue.length > 0) {\n            const v = queue.shift();\n            order.push(v);\n            this.neighbours[v].forEach(n => {\n                if (--indeg[n] == 0)\n                    queue.push(n);\n            });\n        }\n        return order;\n    }\n    \n    bfs(vertex) {\n        const self = this;\n        const visited = new Array(this.numVertices()).fill(false);\n        const trace = [];\n        const queue = [];\n        queue.push(vertex);\n        visited[vertex] = true;\n        while (queue.length > 0) {\n            vertex = queue.shift();\n            self.neighbours[vertex].forEach(neighbour => {\n                if (!visited[neighbour]) {\n                    queue.push(neighbour);\n                    visited[neighbour] = true;\n                    trace.push([vertex, neighbour]);\n                }\n            });\n        }\n        return trace;\n    }\n\n    // HELPER FUNCTIONS\n\n    // make adjacency lists from a given set of edges\n    static adjacencyLists(n, edges, reverse=false) {\n        const neighbours = [...Array(n)].map(i => []);\n        edges.forEach(edge => {\n            let [a, b] = edge;\n            if (reverse)\n                [a, b] = [b, a];\n            neighbours[a].push(b);\n        });\n        return neighbours;\n    }\n    \n    // check if two edges are equal\n    static equalEdges(g1, g2, directed=true) {\n        if (!g1 || !g2)\n            return false;\n        var [a1, b1] = g1;\n        var [a2, b2] = g2;\n        if (directed)\n            return a1 == a2 && b1 == b2;\n        else\n            return (a1 == a2 && b1 == b2) || (a1 == b2 && a2 == b1);\n    }\n\n    // check if edge is in the given set of edges\n    static inEdgeSet(edge, edges, directed) {\n        return edges.some(e => Graph.equalEdges(e, edge, directed));\n    }\n\n    // check if two sets of edges are equal (order is not important)\n    static edgeSetsEqual(set1, set2, directed) {\n        return set1.length == set2.length &&\n               set1.every(edge => Graph.inEdgeSet(edge, set2, directed));\n    }\n\n    // check if two arrays of edges are equal (order is important)\n    static edgeArraysEqual(arr1, arr2, directed) {\n        if (arr1.length != arr2.length)\n            return;\n        return arr1.every((edge, i) => Graph.equalEdges(edge, arr2[i], directed))\n    }\n\n    // check if array of edges contains duplicates\n    static edgeArrayDistinct(edges, directed) {\n        return edges.every((edge, i) => !Graph.inEdgeSet(edge, edges.slice(0, i), directed));\n    }\n\n    \n    // format a vertex label using given numeration style \n    static vertexString(vertex, numerationStyle) {\n        if (numerationStyle == \"A\")\n            return String.fromCharCode('A'.charCodeAt(0) + vertex);\n        else if (numerationStyle == \"a\")\n            return String.fromCharCode('a'.charCodeAt(0) + vertex);\n        else if (numerationStyle == \"\")\n            return \"\";\n        else\n            return vertex;\n    }\n}\n\nclass WeightedGraph extends Graph {\n    constructor(directed=true,n=0) {\n        super(directed, n)\n        this.weighted = true;\n        this.directed = directed;\n    }\n\n    static directed(n=0) {\n        return new WeightedGraph(true, n);\n    }\n\n    static undirected(n=0) {\n        return new WeightedGraph(false, n);\n    }\n    \n    emptyGraph(n) {\n        super.emptyGraph(n);\n        this.weights = Array.from({length: n}, () => Array(n).fill(undefined));\n    }\n\n    addEdge(i, j, w) {\n        super.addEdge(i, j);\n        this.weights[i][j] = w;\n        if (!this.directed)\n            this.weights[j][i] = w;\n    }\n\n\n    setWeight(i, j, w) {\n        this.weights[i][j] = w;\n        if (!this.directed)\n            this.weights[j][i] = w;\n    }\n\n    getWeight(i, j) {\n        return this.weights[i][j];\n    }\n    \n    getWeightedEdges() {\n        const n = this.numVertices();\n        const edges = [];\n        for (let vertex = 0; vertex < n; vertex++)\n            this.neighbours[vertex].forEach(neighbour => {\n                if (this.directed || vertex < neighbour)\n                    edges.push([this.weights[vertex][neighbour], vertex, neighbour]);\n            });\n        return edges;\n    }\n\n    randomWeights(minWeight, maxWeight) {\n        const n = this.numVertices();\n        for (let i = 0; i < n; i++)\n            for (let j = 0; j < n; j++) {\n                const w = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.random)(minWeight, maxWeight);\n                if (this.hasEdge(i, j))\n                    this.setWeight(i, j, w);\n            }\n    }\n\n    randomDifferentWeights(minWeight, maxWeight) {\n        const weights = [];\n        for (let w = minWeight; w <= maxWeight; w++)\n            weights.push(w);\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.shuffle)(weights);\n        this.getEdges().forEach((edge, i) => {\n            this.setWeight(...edge, weights[i]);\n        });\n    }\n\n    closeEdges(postion, eps) {\n        Graph.fullGraphEdges(this.numVertices(), this.directed).forEach(edge => {\n            const [from, to] = edge;\n            if (distance(postion[from][0], postion[from][1], postion[to][0], postion[to][1]) <= eps)\n                this.addEdge(from, to);\n        });\n    }\n\n    euclideanWeights(position) {\n        this.getEdges().forEach(edge => {\n            const [from, to] = edge;\n            this.setWeight(from, to, distance(position[from][0], position[from][1], position[to][0], position[to][1]));\n        });\n    }\n\n    randomGraph(numVertices, numEdges, minWeight=1, maxWeight=100) {\n        super.randomGraph(numVertices, numEdges);\n        this.randomWeights(minWeight, maxWeight);\n    }\n\n    fullGraph(numVertices, minWeight=1, maxWeight=100) {\n        super.fullGraph(numVertices);\n        this.randomWeights(minWeight, maxWeight);\n    }\n\n    latticeGraph(m, n, minWeight=1, maxWeight=100) {\n        super.latticeGraph(m, n);\n        this.randomWeights(minWeight, maxWeight);\n    }\n    \n    dijkstra(vertex=0) {\n        const n = this.numVertices();\n        let numChanges = 0;\n        const vertexOrder = []\n        const table = [];\n        const dist = new Array(n).fill(Infinity);\n        dist[vertex] = 0;\n        table.push([...dist]);\n        \n        const isSolved = new Array(n).fill(false);\n        const parents = [new Array(n).fill(null)];\n        for (let i = 0; i < n; i++) {\n            let min = -1;\n            for (let j = 0; j < n; j++) {\n                if (isSolved[j])\n                    continue;\n                if (min == -1 || dist[j] < dist[min])\n                    min = j;\n            }\n            isSolved[min] = true;\n            vertexOrder.push(min);\n            const minParents  = [...parents[parents.length - 1]];\n            this.neighbours[min].forEach(neighbour => {\n                if (dist[min] + this.weights[min][neighbour] < dist[neighbour]) {\n                    minParents[neighbour] = min;\n                    if (dist[neighbour] < Infinity)\n                        numChanges++;\n                    dist[neighbour] = dist[min] + this.weights[min][neighbour];\n                }\n            });\n            table.push([...dist]);\n\t    parents.push(minParents);\n        }\n        return {dist: dist, vertexOrder: vertexOrder, table: table, parents: parents, numChanges: numChanges};\n    }\n\n    bellmanFord(vertex = 0) {\n        const dist = new Array(this.numVertices()).fill(Infinity);\n        const parent = new Array(this.numVertices()).fill(null);\n        dist[vertex] = 0;\n        const commands = [];\n        for (let i = 0; i < graph.numVertices() - 1; i++) {\n            this.getEdges().forEach(edge => {\n                let [u, v] = edge;\n                if (dist[u] + graph.getWeight(u, v) < dist[v]) {\n                    dist[v] = dist[u] + graph.getWeight(u, v);\n                    parent[v] = u;\n                }\n            });\n        }\n        const negativeCycle = this.getEdges().some(edge => {\n            const [u, v] = edge;\n            return dist[u] + graph.getWeight(u, v) < dist[v];\n        });\n        return {dist: dist, parents: parent, negativeCycle: negativeCycle};\n    }\n\n    prim() {\n        let mstWeight = 0;\n\tconst mstEdges = [];\n\tlet vertex = 0;\n\tconst vertexOrder = [];\n\tvertexOrder.push(vertex);\n\tlet candidateEdges = [];\n\twhile (vertexOrder.length < this.numVertices()) {\n\t    candidateEdges = candidateEdges.filter(g => g[2] != vertex);\n\t    this.neighbours[vertex].forEach(neighbour => { \n\t\tif (!vertexOrder.includes(neighbour))\n\t\t    candidateEdges.push([this.weights[vertex][neighbour], vertex, neighbour]);\n\t    });\n\t    let minEdge = 0;\n\t    for (let edge = 1; edge < candidateEdges.length; edge++) {\n\t\tif (candidateEdges[edge][0] < candidateEdges[minEdge][0] ||\n                    (candidateEdges[edge][0] == candidateEdges[minEdge][0] &&\n                     candidateEdges[edge][2] < candidateEdges[minEdge][2]))\n\t\t    minEdge = edge;\n\t    }\n\t    vertex = candidateEdges[minEdge][2];\n\t    mstEdges.push(candidateEdges[minEdge]);\n            mstWeight += candidateEdges[minEdge][0];\n\t    candidateEdges.splice(minEdge, 1);\n\t    vertexOrder.push(vertex);\n\t}\n\treturn {vertexOrder: vertexOrder, mstEdges: mstEdges, mstWeight: mstWeight};\n    }\n\n    kruskal() {\n        const n = this.numVertices();\n        const sortedEdges = this.getWeightedEdges().sort((a, b) => {\n            if (a[0] < b[0]) return -1;\n            else if (a[0] > b[0]) return 1;\n            else if (a[1] < b[1]) return -1;\n            else if (a[1] > b[1]) return 1;\n            else return a[2] - b[2];\n        });\n        \n        const color = new Array(n);\n        for (var vertex = 0; vertex < n; vertex++)\n            color[vertex] = vertex;\n        \n        const mstEdges = [];\n        const allEdges = []\n        let mstWeight = 0;\n        for (let i = 0; i < sortedEdges.length; i++) {\n            var [weight, vertexA, vertexB] = sortedEdges[i];\n            if (color[vertexA] != color[vertexB]) {\n                mstEdges.push([weight, vertexA, vertexB]);\n                mstWeight += weight;\n                allEdges.push([vertexA, vertexB, true]);\n            } else\n                allEdges.push([vertexA, vertexB, false]);\n\n            const colorA = color[vertexA], colorB = color[vertexB];\n            for (let vertex = 0; vertex < n; vertex++)\n                if (color[vertex] == colorA)\n                    color[vertex] = colorB;\n        }\n        return {mstWeight: mstWeight, mstEdges: mstEdges, allEdges: allEdges};\n    }\n\n    floydWarshall() {\n\tfunction cloneMatrix(M) {\n\t    const clone = new Array(M.length);\n\t    for (var i = 0; i < M.length; i++)\n\t\tclone[i] = [...M[i]];\n\t    return clone;\n\t}\n\n\tconst n  = this.numVertices();\n\tconst M = new Array(n);\n        const Mp = new Array(n);\n\tfor (let i = 0; i < n; i++) {\n\t    M[i] = new Array(n).fill(Infinity);\n\t    Mp[i] = new Array(n).fill([]);\n\t}\n\n        for (let i = 0; i < n; i++) {\n\t    this.neighbours[i].forEach(j => {\n\t\tM[i][j] = this.weights[i][j];\n\t\tMp[i][j] = [i, j];\n\t    });\n\t    M[i][i] = 0;\n\t}\n        \n\tlet Ms = [cloneMatrix(M)];\n\tlet Mps = [cloneMatrix(Mp)];\n\n\tfor (let k = 0; k < n; k++) {\n\t    for (let i = 0; i < n; i++)\n\t\tfor (let j = 0; j < n; j++) {\n\t\t    if (M[i][k] + M[k][j] < M[i][j])\n\t\t\tMp[i][j] = Mp[i][k].concat(Mp[k][j].slice(1));\n\t\t    M[i][j] = Math.min(M[i][j], M[i][k] + M[k][j]);\n\t\t}\n\t    Ms.push(cloneMatrix(M));\n\t    Mps.push(cloneMatrix(Mp));\n\t}\n\n\treturn [Ms, Mps];\n    }\n}\n\n\nclass BinaryTree extends Graph {\n    constructor() {\n        super(0, true);\n        this.neighbours = []\n    }\n\n    addVertex() {\n        const n = this.numVertices();\n        this.neighbours.push([null, null]);\n        return n;\n    }\n\n    numVertices() {\n        return this.neighbours.length;\n    }\n\n    setLeftChild(parent, child) {\n        this.neighbours[parent][0] = child;\n    }\n    \n    setRightChild(parent, child) {\n        this.neighbours[parent][1] = child;\n    }\n}\n\n\nclass GraphDrawingCanvas {\n    constructor(canvas) {\n        this._canvas = canvas;\n        this._ctx = canvas.getContext(\"2d\");\n        \n        // Set display size (css pixels).\n        this._canvas.style.width = canvas.width + \"px\";\n        this._canvas.style.height = canvas.height + \"px\";\n\n        // Set actual size in memory (scaled to account for extra pixel density).\n        const scale = window.devicePixelRatio;\n        canvas.width = canvas.width * scale;\n        canvas.height = canvas.height * scale;\n\n        // Normalize coordinate system to use css pixels.\n        this._ctx.scale(scale, scale);\n        this._scale = scale;\n\n        this._listeners = [];\n    }\n\n    width() {\n        return this._canvas.width / this._scale;\n    }\n\n    height() {\n        return this._canvas.height / this._scale;\n    }\n\n    ctx() {\n        return this._ctx;\n    }\n\n    getBoundingClientRect() {\n        return this._canvas.getBoundingClientRect();\n    }\n\n    addEventListener(event, handler) {\n        this._canvas.addEventListener(event, handler);\n        this._listeners.push([event, handler]);\n    }\n\n    removeAllListeners() {\n        this._listeners.forEach(pair => {\n            const [event, handler] = pair;\n            this._canvas.removeEventListener(event, handler);\n        });\n        this._listeners = [];\n    }\n}\n\nclass GraphDrawing {\n    constructor(graph, canvas, width, height) {\n        if (width)\n            canvas.width = width;\n        if (height)\n            canvas.height = height;\n\n        if (canvas != undefined)\n            this.canvas = new GraphDrawingCanvas(canvas);\n\n        this.setCSS();\n        \n        this.setGraph(graph);\n        \n        this.singleSelectVertex = true;\n        this.singleSelectEdge = false;\n\n        this.drawVertices = true;\n        this.drawEdges = true;\n    }\n\n    setGraph(graph) {\n        this.graph = graph;\n        \n        const n = graph.numVertices();\n        \n        this.vertexPosition = Array.from({length: n}, () => [0, 0]);\n        \n        this.vertexLabels = Array.from({length: n}, () => undefined);\n        this.vertexContent = Array.from({length: n}, () => undefined);\n        this.vertexCSS = Array.from({length: n}, () => undefined);\n        \n        this.edgeLabels = {}\n        this.edgeCSS = {}\n\n        this.drawFocusVertex = false;\n        this.focusVertex = undefined;\n        this.focusEdge = undefined;\n        \n        this.selectedVertices = [];\n        this.selectedEdges = [];\n\n        this.canvas.removeAllListeners();\n\n        if (graph.weighted)\n            this.setWeightLabels();\n        \n        this.draw();\n    }\n\n    width() {\n        return this.canvas.width();\n    }\n\n    height() {\n        return this.canvas.height();\n    }\n    \n    numVertices() {\n        return this.graph.numVertices();\n    }\n\n    addVertex() {\n        const vertex = this.graph.addVertex();\n        this.vertexPosition.push([0, 0]);\n        this.vertexLabels.push(undefined);\n        this.vertexCSS.push(undefined);\n        return vertex;\n    }\n\n    setPosition(i, pos) {\n        this.vertexPosition[i] = pos;\n    }\n\n    getPosition(i) {\n        return this.vertexPosition[i];\n    }\n\n    curveDoubleEdges() {\n        if (!this.graph.directed)\n            return;\n        for (const edge of this.graph.getEdges()) {\n            if (this.graph.hasEdge(edge[1], edge[0])) {\n                this.setEdgeCSSProperty(edge, \"curvature\", 0.3);\n                this.setEdgeCSSProperty([edge[1], edge[0]], \"curvature\", 0.3);\n            }\n        }\n    }\n    \n\n    // VERTEX ARRANGEMENT\n    \n    static circularArrangementPosition(n, cx, cy, r) {\n        if (n == 1) return [[cx, cy]];\n        function position(vertex) {\n            const alpha = Math.PI / 2 + vertex * (2*Math.PI / n);\n            const x = cx + r * Math.cos(alpha);\n            const y = cy - r * Math.sin(alpha);\n            return [x, y];\n        }\n        return [...Array(n).keys()].map(vertex => position(vertex));\n    }\n    \n    circularArrangement(cx, cy, r) {\n        this.vertexPosition = GraphDrawing.circularArrangementPosition(this.numVertices(), cx, cy, r);\n        this.draw();\n    }\n\n    static latticeArrangementPosition(m, n, x0, y0, width, height) {\n        function position(vertex, m, n) {\n            const j = vertex % n;\n            const i = Math.floor(vertex / n);\n            const w = width / (n-1), h = height / (m-1);\n            const x = x0 + j * w;\n            const y = y0 + i * h;\n            return [x, y];\n        }\n        return [...Array(m*n).keys()].map(vertex => position(vertex, m, n));\n    }\n    \n    latticeArrangement(m, n, x0, y0, width, height) {\n        this.vertexPosition = GraphDrawing.latticeArrangementPosition(m, n, x0, y0, width, height);\n        this.draw();\n    }\n\n    randomArrangement(x0, y0, width, height, minDist) {\n        function random(a, b) {\n            return a + Math.random() * (b - a);\n        }\n        for (let v = 0; v < this.numVertices(); v++) {\n            do {\n                this.vertexPosition[v] = [random(x0, x0 + width), random(y0, y0 + height)]\n            } while(this.graph.getVertices().slice(0, v).some(vv => distance(this.vertexPosition[vv][0], this.vertexPosition[vv][1], this.vertexPosition[v][0], this.vertexPosition[v][1]) < minDist));\n        }\n        this.draw();\n    }\n\n    treeCoordinates(treeNeighbours, root, xStart, yStart) {\n        // we arrange the tree recursively\n        // visited nodes during tree traversal\n        const visited = new Array(this.numVertices()).fill(false);\n        // maximal dept of a tree node\n        let maxDepth = 0;\n\n        const coords = new Array(this.numVertices());\n        // we draw the tree rooted at the given depth on a coordinate xStart\n        // and return the x coordinate where its next sibling on that depth should be\n        function positionRec(vertex, xStart, depth) {\n            if (vertex == null)\n                return xStart+1;\n            \n            visited[vertex] = true;\n            if (depth > maxDepth)\n                maxDepth = depth;\n            let x = xStart;\n            treeNeighbours[vertex].forEach(neighbour => {\n                x = positionRec(neighbour, x, depth+1);\n            });\n            \n            if (treeNeighbours[vertex].length == 0) {\n                coords[vertex] = [xStart, yStart + depth];\n                return xStart+1;\n            } else {\n                coords[vertex] = [(x + xStart - 1) / 2, yStart + depth];\n                return x;\n            }\n        }\n\n        const xEnd = positionRec(root, xStart, yStart) - 1;\n        return {visited: visited, coords: coords, xEnd: xEnd, yEnd: yStart + maxDepth};\n    }\n\n\n    treeArrangementPositionNeigbours(initialVertexPosition, root, treeNeighbours, x0, y0, width, height, reverse=false) {\n        // special case when root has no edges\n        if (treeNeighbours[root].filter(neighbour => neighbour != null).length == 0) {\n            const result = [...initialVertexPosition];\n            result[root] = [x0 + width/2, y0 + height/2];\n            return result;\n        }\n        \n        const xStart = 0;\n        const yStart = 0;\n        const coordinates = this.treeCoordinates(treeNeighbours, root, xStart, yStart);\n        \n        let dh = height / (coordinates.yEnd - yStart + 1);\n        let dw = width / (coordinates.xEnd - xStart + 1);\n        return initialVertexPosition.map((p, vertex) => {\n            if (!coordinates.visited[vertex])\n                return p;\n            else {\n                const [x, y] = coordinates.coords[vertex];\n                return [x0 + dw / 2 + x * dw, y0 + dh / 2 + y * dh];\n            }\n        });\n    }\n    \n    \n    treeArrangementPosition(initialVertexPosition, root, treeEdges, x0, y0, width, height, reverse=false) {\n        // build adjacency lists for the tree\n        const n = this.numVertices()\n        const treeNeighbours = Graph.adjacencyLists(n, treeEdges, reverse);\n        return this.treeArrangementPositionNeigbours(initialVertexPosition, root, treeNeighbours, x0, y0, width, height, reverse);\n    }\n\n    treeArrangement(root, treeEdges, x0, y0, width, height, reverse=false) {\n        this.vertexPosition = this.treeArrangementPosition(this.vertexPosition, root, treeEdges, x0, y0, width, height, reverse);\n        this.draw();\n    }\n\n    treeArrangementNeighbours(root, treeNeighbours, x0, y0, width, height, reverse=false) {\n        this.vertexPosition = this.treeArrangementPositionNeigbours(this.vertexPosition, root, treeNeighbours, x0, y0, width, height, reverse);\n        this.draw();\n    }\n    \n    forrestArrangementPosition(initialVertexPosition, roots, forestEdges, x0, y0, width, height, reverse=false) {\n        // build adjacency lists for the forest\n        const n = this.numVertices()\n        const forrestNeighbours = Graph.adjacencyLists(n, forestEdges, reverse);\n\n        let xStart = 0;\n        let xEnd = 0;\n        let yStart = 0;\n        let yEnd = 0;\n        const coordinates = {\n            visited: Array(n).fill(false),\n            coords: Array(n)\n        }\n        roots.forEach(root => {\n            const  c = this.treeCoordinates(forrestNeighbours, root, xStart, yStart);\n            for (let i = 0; i < n; i++) {\n                if (c.visited[i]) {\n                    coordinates.visited[i] = true;\n                    coordinates.coords[i] = c.coords[i];\n                }\n            }\n            xEnd = c.xEnd;\n            xStart = c.xEnd + 1;\n            yEnd = Math.max(yEnd, c.yEnd);\n        });\n\n        let dh = height / (yEnd + 1);\n        let dw = width / (xEnd  + 1);\n        return initialVertexPosition.map((p, vertex) => {\n            if (!coordinates.visited[vertex])\n                return p;\n            else {\n                const [x, y] = coordinates.coords[vertex];\n                return [x0 + dw / 2 + x * dw, y0 + dh / 2 + y * dh];\n            }\n        });\n    }\n\n    forrestArrangement(roots, forestEdges, x0, y0, width, height, reverse=false) {\n        this.vertexPosition = this.forrestArrangementPosition(this.vertexPosition, roots, forestEdges, x0, y0, width, height, reverse);\n        this.draw();\n    }\n    \n    lineArrangementPosition(order, x0, y0, w) {\n        const position = new Array(this.graph.numVertices()).fill([0, 0]);\n        let index = new Array(order.length);\n        for (let i = 0; i < order.length; i++)\n            index[order[i]] = i;\n\n        position[order[0]] = [x0, y0];\n        if (order.length == 1)\n            return;\n        const dw = w / (order.length - 1);\n        for (let i = 1; i < order.length; i++)\n            position[order[i]] = [x0 + i*dw, y0];\n        return position;\n    }\n\n    lineArrangement(order, x0, y0, w) {\n        this.vertexPosition = this.lineArrangementPosition(order, x0, y0, w);\n    }\n\n    twoLevelCircularArrangement(x0, y0, w, h, component) {\n        const numComponents = Math.max(...component) + 1;\n        const componentCard = new Array(numComponents).fill(0);\n        component.forEach(c => {componentCard[c]++;});\n        const D = Math.min(w/2, h/2);\n        const R = 2*D/3;\n        const r = R*Math.sin(Math.PI / numComponents) * (2/3);\n        const componentCenter = GraphDrawing.circularArrangementPosition(numComponents, x0 + w/2, y0 + h/2, R)\n        const positions = [];\n        componentCard.forEach((card, c) => {\n            let [cx, cy] = componentCenter[c];\n            positions.push(GraphDrawing.circularArrangementPosition(card, cx, cy, r));\n        });\n        component.forEach((c, v) => {\n            this.vertexPosition[v] = positions[c][--componentCard[c]];\n        });\n        this.draw();\n    }\n    \n\n    shake(n) {\n        this.vertexPosition = this.vertexPosition.map(p => [p[0] + Math.random() * n - n/2, p[1] + Math.random() * n - n/2])\n    }\n\n    animateArrangement(newVertexPosition, numSteps=30, animationTime=500, animationDelay, callback) {\n        if (animationDelay == undefined)\n            animationDelay = animationTime / 2;\n        \n        this.draw();\n        let t = 0;\n        let step = 0;\n        const startVertexPosition = [...this.vertexPosition];\n        const self = this;\n        function showStep() {\n            for (let vertex = 0; vertex < self.numVertices(); vertex++) {\n                const [x0, y0] = startVertexPosition[vertex];\n                const [x1, y1] = newVertexPosition[vertex];\n                self.vertexPosition[vertex] = [(1-t)*x0 + t*x1, (1-t)*y0 + t*y1];\n            }\n            self.draw();\n            t += 1 / (numSteps-1);\n            step++;\n            if (step < numSteps)\n                setTimeout(showStep, animationTime/(numSteps - 1));\n            else {\n                if (callback != undefined)\n                    callback();\n            }\n        }\n        setTimeout(showStep, animationDelay);\n    }\n\n    // VERTEX CONTENT\n    getVertexContent(vertex, numerationStyle) {\n        if (this.vertexContent[vertex] !== undefined) {\n            const str = this.vertexContent[vertex];\n            if (/^-?\\d+$/.test(str))\n                return parseInt(str);\n            else\n                return str;\n        } else\n            return Graph.vertexString(vertex, numerationStyle);\n    }\n\n    setVertexContent(vertex, content) {\n        if (this.vertexContent[vertex] === content)\n            return false;\n        this.vertexContent[vertex] = content;\n        this.draw();\n        return true;\n    }\n\n    // LABELS\n    getVertexLabel(vertex) {\n        return this.vertexLabels[vertex];\n    }\n    \n    setVertexLabel(vertex, label) {\n        if (this.vertexLabels[vertex] == label)\n            return false;\n        this.vertexLabels[vertex] = label;\n        this.draw();\n        return true;\n    }\n\n    removeVertexLabel(vertex) {\n        return this.setVertexLabel(vertex, undefined);\n    }\n\n    removeAllVertexLabels() {\n        for (let vertex = 0; vertex < this.numVertices(); vertex++)\n            this.removeVertexLabel(vertex);\n    }\n\n    edgeKey(edge) {\n        return JSON.stringify(this.graph.normalizeEdge(edge));\n    }\n\n    getEdgeLabel(edge) {\n        return this.edgeLabels[this.edgeKey(edge)];\n    }\n\n    setEdgeLabel(edge, label) {\n        const key = this.edgeKey(edge);\n        if (this.edgeLabels[key] == label)\n            return false;\n        this.edgeLabels[key] = label;\n        this.draw();\n        return true;\n    }\n\n    removeEdgeLabel(edge) {\n        return this.setEdgeLabel(edge, undefined);\n    }\n\n    removeAllEdgeLabels() {\n        this.graph.getEdges().forEach(edge => this.removeEdgeLabel(edge));\n    }\n\n    getLabeledVertices() {\n        const vertices = []\n        for (let vertex = 0; vertex < this.numVertices(); vertex++) {\n            if (this.vertexLabels[vertex] != undefined)\n                vertices.push(vertex);\n        }\n        return vertices;\n    }\n\n    numLabeledVertices() {\n        let vertices = 0;\n        for (let vertex = 0; vertex < this.numVertices(); vertex++) {\n            if (this.vertexLabels[vertex] != undefined)\n                vertices++;\n        }\n        return vertices;\n    }\n\n    vertexOrderByLabel() {\n        const labels = []\n        for (let vertex = 0; vertex < this.numVertices(); vertex++) {\n            const label = this.vertexLabels[vertex];\n            if (label != undefined)\n                labels.push([label, vertex]);\n            labels.sort((a, b) => a[0] - b[0]);\n        }\n        return labels.map(x => x[1]);\n    }\n\n    setWeightLabels() {\n        if (!this.graph.weighted)\n            return false;\n        const edges = this.graph.getWeightedEdges();\n        edges.forEach(edge => this.setEdgeLabel([edge[1], edge[2]], edge[0]));\n        return true;\n    }\n\n    \n    // CSS\n    getVertexCSS(vertex) {\n        return this.vertexCSS[vertex];\n    }\n\n    getVertexCSSProperty(vertex, property) {\n        const css = this.getVertexCSS(vertex);\n        if (css === undefined)\n            return undefined;\n        return css[property];\n    }\n\n    setVertexCSS(vertex, css) {\n        for (const property in css)\n            this.setVertexCSSProperty(vertex, property, css[property]);\n        this.draw();\n    }\n\n    setVertexCSSProperty(vertex, property, value) {\n        if (this.getVertexCSS(vertex, property) == value)\n            return false;\n        if (!this.vertexCSS[vertex])\n            this.vertexCSS[vertex] = {};\n        this.vertexCSS[vertex][property] = value;\n        this.draw();\n        return true;\n    }\n    \n    removeVertexCSS(vertex) {\n        if (this.getVertexCSS(vertex) == undefined)\n            return false;\n        delete this.vertexCSS[vertex];\n        this.draw();\n        return true;\n    }\n\n    removeAllVertexCSS() {\n        this.vertexCSS = Array(this.numVertices());\n        this.draw();\n    }\n\n    getEdgeCSS(edge) {\n        return this.edgeCSS[this.edgeKey(edge)];\n    }\n\n    getEdgeCSSProperty(edge, property) {\n        const css = this.getEdgeCSS(edge);\n        if (css === undefined)\n            return undefined;\n        return css[property];\n    }\n\n    setEdgeCSSProperty(edge, property, value) {\n        if (this.getEdgeCSSProperty(edge, property) == value)\n            return false;\n        const key = this.edgeKey(edge);\n        if (this.edgeCSS[key] == undefined)\n            this.edgeCSS[key] = {};\n        this.edgeCSS[key][property] = value;\n        this.draw();\n        return true;\n    }\n    \n    setEdgeCSS(edge, css) {\n        for (const property in css)\n            this.setEdgeCSSProperty(edge, property, css[property]);\n    }\n\n    removeEdgeCSS(edge) {\n        if (this.getEdgeCSS(edge) == undefined)\n            return false;\n        delete this.edgeCSS[this.edgeKey(edge)];\n        this.draw();\n        return true;\n    }\n\n    hideEdge(edge) {\n        this.setEdgeCSSProperty(edge, \"show\", false);\n    }\n\n    showEdge(edge) {\n        this.setEdgeCSSProperty(edge, \"show\", true);\n    }\n    \n    // set css to the vertex currently in focus\n    setFocusVertexCSS(css) {\n        if (this.focusVertex == undefined)\n            return false;\n        return this.setVertexCSS(this.focusVertex);\n    }\n    \n    // set css to the edge currently in focus\n    setFocusEdgeCSS(css) {\n        if (this.focusEdge == undefined)\n            return false;\n        return this.setEdgeCSS(this.focusEdge);\n    }\n\n    // reset both vertex and edge css styles\n    resetAllCSS() {\n        this.vertexCSS = Array(this.vertexCSS.length).fill(undefined);\n        this.edgeCSS = {};\n        this.draw();\n        return true;\n    }\n\n    // MOUSE POSITION    \n    // is point (x, y) close to the given vertex?\n    closeToVertex(vertex, x, y, eps = 15) {\n        const [xc, yc] = this.vertexPosition[vertex];\n        return (x - xc)*(x - xc) + (y - yc)*(y - yc) <= eps * eps;\n    }\n\n    // which node lies on point (x, y)\n    vertexOn(x, y) {\n        const n = this.numVertices();\n        for (let vertex = 0; vertex < n; vertex++)\n            if (this.closeToVertex(vertex, x, y))\n                return vertex;\n        return undefined;\n    }\n\n    // is point (x, y) close to the given edge [vertex1, vertex2]?\n    closeToEdge(edge, x, y, curvature=0) {\n        if (curvature == 0) {\n            var [vertex1, vertex2] = edge;\n            var [x0, y0] = this.vertexPosition[vertex1];\n            var [x1, y1] = this.vertexPosition[vertex2];\n            var eps = 1;\n            return Math.abs(distance(x, y, x0, y0) + distance(x, y, x1, y1) - distance(x0, y0, x1, y1)) < eps;\n        } else {\n            function pointOnQuadraticCurve(x, y, P0, P1, P2, eps = 1) {\n                function quadraticCurveEquation(t, P0, P1, P2) {\n                    const xT = (1 - t) ** 2 * P0[0] + 2 * (1 - t) * t * P1[0] + t ** 2 * P2[0];\n                    const yT = (1 - t) ** 2 * P0[1] + 2 * (1 - t) * t * P1[1] + t ** 2 * P2[1];\n                    return { x: xT, y: yT };\n                }\n                \n                const n = 50;\n                const dt = 1 / n;\n                let t = 0;\n                for (let i = 0; i <= n; i++) {\n                    t += dt;\n                    const { x: xT, y: yT } = quadraticCurveEquation(t, P0, P1, P2);\n                    const distance = Math.sqrt((xT - x) ** 2 + (yT - y) ** 2);\n                    if (distance < eps)\n                        return true;\n                }\n                \n                return false;\n            }\n            var [vertex1, vertex2] = edge;\n            var [x0, y0] = this.vertexPosition[vertex1];\n            var [x1, y1] = this.vertexPosition[vertex2];\n            var [mx, my] = [(x0 + x1) / 2, (y0 + y1) / 2];\n            return pointOnQuadraticCurve(x, y, [x0, y0], [mx - curvature*(my - y0), my + curvature*(mx - x0)], [x1, y1], 5);\n        }\n    }\n    \n    // which edge lies on point (x, y)\n    edgeOn(x, y) {\n        return this.graph.getEdges().find(edge => {\n            let curvature = this.getEdgeCSSProperty(edge, \"curvature\");\n            if (curvature == undefined) curvature = this.CSS.edge.curvature;\n            return this.closeToEdge(edge, x, y, curvature)\n        });\n    }\n\n    // FOCUSING\n\n    // focus vertex under the mouse pointer that is at (x, y)\n    focusVertexOn(x, y) {\n        const vertex = this.vertexOn(x, y);\n        if (vertex != this.focusVertex) {\n            this.focusEdge = undefined;\n            this.focusVertex = vertex;\n            this.draw();\n            return true;\n        }\n        return false;\n    }\n\n    // focus edge under the mouse pointer that is at (x, y)\n    focusEdgeOn(x, y) {\n        if (this.vertexOn(x, y) != undefined) {\n            if (!this.focusEdge)\n                return false;\n            \n            this.focusEdge = undefined;\n            return true;\n        }\n        const edge = this.edgeOn(x, y);\n        if (edge != this.focusEdge) {\n            this.focusEdge = edge;\n            this.draw();\n            return true;\n        }\n        return false;\n    }\n\n    // SELECTION\n\n    // check if the given vertex is selected\n    isSelectedVertex(vertex) {\n        return this.selectedVertices.includes(vertex)\n    }\n\n    // check if the given edge is selected\n    isSelectedEdge(edge) {\n        for (const e of this.selectedEdges)\n            if (Graph.equalEdges(e, edge))\n                return true;\n        return false;\n    }\n    \n    // select a given vertex\n    selectVertex(vertex) {\n        if (!this.isSelectedVertex(vertex)) {\n            if (this.singleSelectVertex)\n                this.selectedVertices = [];\n            this.selectedVertices.push(vertex);\n            this.draw();\n            return true;\n        }\n        return false;\n    }\n\n    // select a given edge\n    selectEdge(edge) {\n        edge = this.graph.normalizeEdge(edge);\n        if (!this.isSelectedEdge(edge)) {\n            if (this.singleSelectEdge)\n                this.selectedEdges = [];\n            this.selectedEdges.push(edge);\n            this.draw();\n            return true;\n        }\n        return false;\n    }\n\n    // select vertex on given position\n    selectVertexOn(x, y) {\n        const vertex = this.vertexOn(x, y);\n        if (vertex == undefined)\n            return false;\n        return this.selectVertex(vertex);\n    }\n\n    // select edge on given position\n    selectEdgeOn(x, y) {\n        if (this.vertexOn(x, y) != undefined)\n            return false;\n        const edge = this.edgeOn(x, y);\n        if (edge == undefined)\n            return false;\n        return this.selectEdge(edge);\n    }\n\n    // select vertex currently in focus\n    selectFocusVertex() {\n        if (this.focusVertex)\n            return this.selectVertex(this.focusVertex);\n        return false;\n    }\n\n    // select edge currently in focus\n    selectFocusEdge() {\n        if (this.focusEdge)\n            return this.selectEdge(this.focusEdge);\n        return false;\n    }\n    \n    // deselect a given vertex\n    deselectVertex(vertex) {\n        if (this.isSelectedVertex(vertex)) {\n            this.selectedVertices = this.selectedVertices.filter(v => v !== vertex);\n            this.draw();\n            return true;\n        }\n        return false;\n    }\n\n    // deselect a given edge\n    deselectEdge(edge) {\n        if (this.isSelectedEdge(edge)) {\n\t    this.selectedEdges = this.selectedEdges.filter(e => !Graph.equalEdges(e, edge));\n            this.draw();\n            return true;\n        }\n        return false;\n    }\n    \n    // deselect vertex currently in focus\n    deselectFocusVertex() {\n        if (this.focusVertex)\n            return this.deselectVertex(this.focusVertex);\n        return false;\n    }\n\n    // deselect edge currently in focus\n    deselectFocusEdge() {\n        if (this.focusEdge)\n            return this.deselectEdge(this.focusEdge);\n        return false;\n    }\n\n    \n    // deselect all vertices\n    deselectAllVertices() {\n        if (this.selectedVertices != []) {\n            this.selectedVertices = [];\n            this.draw();\n            return true;\n        }\n        return false;\n    }\n\n    // deselect all edges\n    deselectAllEdges() {\n        if (this.selectedEdges != []) {\n            this.selectedEdges = [];\n            this.draw();\n            return true;\n        }\n        return false;\n    }\n\n    // deselect all vertices and edges\n    deselectAll() {\n        let change = false;\n        change = change || this.deselectAllVertices();\n        change = change || this.deselectAllEdges();\n        return change;\n    }    \n\n    // deselect vertex on the given mouse position (x, y)\n    deselectVertexOn(x, y) {\n        const vertex = this.vertexOn(x, y);\n        if (vertex == undefined)\n            return false;\n        return this.deselectVertex(vertex);\n    }\n\n    // deselect edge on the given mouse position (x, y)\n    deselectEdgeOn(x, y) {\n        const edge = this.edgeOn(x, y);\n        if (edge == undefined)\n            return false;\n        return this.deselectEdge(edge);\n    }\n    \n    // toggle selection of a given vertex\n    toggleSelectVertex(vertex) {\n        if (this.isSelectedVertex(vertex))\n            this.deselectVertex(vertex);\n        else\n            this.selectVertex(vertex);\n    }\n\n    // toggle selection of a given edge\n    toggleSelectEdge(edge) {\n        if (this.isSelectedEdge(edge))\n            this.deselectEdge(edge);\n        else\n            this.selectEdge(edge);\n    }\n\n    // toggle selection of a vertex on the given coordinates (x, y)\n    toggleSelectVertexOn(x, y) {\n        const vertex = this.vertexOn(x, y);\n        if (vertex == undefined)\n            return false;\n        this.toggleSelectVertex(vertex);\n        return true;\n    }\n\n    // toggle selection of an edge on the given coordinates (x, y)\n    toggleSelectEdgeOn(x, y) {\n        if (this.vertexOn(x, y) != undefined)\n            return false;\n        \n        const edge = this.edgeOn(x, y);\n        if (edge == undefined)\n            return false;\n        this.toggleSelectEdge(edge);\n        return true;\n    }\n\n    \n    // MOVING VERTICES\n\n    // moves focused vertex to position (x, y)\n    moveFocusVertex(x, y) {\n        if (this.focusVertex != undefined) {\n            this.vertexPosition[this.focusVertex] = [x, y];\n            this.draw();\n            return true;\n        }\n        return false;\n    }\n\n    // move selectedVertices to (x, y)\n    moveSelectedVertices(x, y) {\n        this.selectedVertices.forEach((vertex) => {\n            this.vertexPosition[vertex] = [x, y];\n        });\n        this.draw();\n    }\n\n    // move selected vertices by (dx, dy)\n    moveSelectedVerticesBy(dx, dy) {\n        this.selectedVertices.forEach((vertex) => {\n            const [x, y] = this.vertexPosition[vertex];\n            this.vertexPosition[vertex] = [x + dx, y + dy];\n        });\n        this.draw();\n    }\n\n    // graph drawing\n    draw() {\n        if (this.canvas == undefined)\n            return;\n        \n        function drawEdgeLine(ctx, x1, y1, x2, y2, width, color, lineStyle, directed, label, labelBackgroundColor, labelPosition, curvature, vertexSize1, vertexSize2) {\n            var d = Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));\n            if (lineStyle == \"dashed\")\n                lineStyle = [5, 5];\n            else if (lineStyle == \"dotted\")\n                lineStyle = [2, 2];\n            else\n                lineStyle = [];\n            \n            ctx.save();\n            ctx.translate(x2, y2);\n            var alpha = Math.atan2(y2 - y1, x2 - x1);\n            ctx.rotate(alpha);\n\n            var bottomX = -d, bottomY = 0;\n            var topX = 0, topY = 0;\n\n            // draw \"line\"\n            ctx.beginPath();\n            ctx.lineWidth = width;\n            ctx.setLineDash(lineStyle);\n            ctx.strokeStyle = color;\n            ctx.moveTo(bottomX, bottomY);\n            const midX = (bottomX + topX) / 2;\n            const midY = -curvature * midX;\n            ctx.quadraticCurveTo(midX, midY, topX, topY);\n            ctx.stroke();\n\n            const Cx = t => bottomX*(1-t)**2 + 2*midX*t*(1-t) + topX*t**2;\n            const Cy = t => bottomY*(1-t)**2 + 2*midY*t*(1-t) + topY*t**2;\n            \n            // draw \"arrow\"\n            if (directed) {\n                if (curvature != 0) {\n                    ctx.save();\n                    const n = 200;\n                    const dt = 1/n;\n                    let t = 1.0;\n                    for (let i = 0; i <= n; i++) {\n                        t -= dt;\n                        if ((Cx(t) - topX)**2 + (Cy(t) - topY)**2 > vertexSize2**2)\n                            break;\n                    }\n\n                    const alpha = Math.atan2(Cy(t + dt) - Cy(t), Cx(t + dt) - Cx(t));\n                    ctx.rotate(alpha);\n                }\n\n                ctx.beginPath();\n                const length = Math.min(15, 2 * (d - vertexSize1 - vertexSize2) / 3);\n                \n                ctx.moveTo(topX - vertexSize2 - length, topY - length / 4);\n                ctx.lineTo(topX - vertexSize2, topY);\n                ctx.stroke();\n                \n                ctx.beginPath();\n                ctx.moveTo(topX - length - vertexSize2, topY + length / 4);\n                ctx.lineTo(topX - vertexSize2, topY);\n                ctx.stroke();\n                \n                if (curvature != 0)\n                    ctx.restore();\n            }\n\n            // print label\n            if (label !== undefined) {\n                label = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.render)(label);\n                const labelSize = \"15px\";\n                ctx.font = labelSize + \" \" + \"Arial\";\n                let labelPositionX, labelPositionY;\n                if (curvature == 0) {\n                    labelPositionX = bottomX + (topX - bottomX)*labelPosition;\n                    labelPositionY = bottomY + (topY - bottomY)*labelPosition;\n                } else {\n                    labelPositionX = Cx(labelPosition);\n                    labelPositionY = Cy(labelPosition);\n                }\n\n                ctx.translate(labelPositionX, labelPositionY);\n                ctx.rotate(-alpha);\n                ctx.beginPath();\n                ctx.arc(0, 0, width+1, 0, 2*Math.PI);\n                ctx.fill();\n\n                const dx = 5 + width, dy = - width;\n                if (labelBackgroundColor !== undefined) {\n                    ctx.globalAlpha = 0.8;\n                    ctx.fillStyle = labelBackgroundColor;\n                    const paddingX = 2, paddingY = 2;\n                    const textWidth = ctx.measureText(label).width + 2*paddingX;\n                    const textHeight = parseInt(labelSize) + 2*paddingY;\n                    ctx.fillRect(dx - paddingX, dy - textHeight + paddingY, textWidth, textHeight);\n                    ctx.globalAlpha = 1;\n                    ctx.strokeStyle = \"black\";\n                    ctx.strokeRect(dx - paddingX, dy - textHeight + paddingY, textWidth, textHeight);\n                }\n\n                ctx.fillStyle = \"black\";\n\t\tctx.textAlign = \"left\";\n\t\tctx.textBaseline = \"bottom\";\n                ctx.fillText(label, dx, dy);\n            }\n            ctx.restore();\n        }\n\n        function drawEdgeLoop(ctx, x, y, width, color, label) {\n            ctx.beginPath();\n            ctx.ellipse(x, y - 10, 10, 15, Math.PI, 0, 2*Math.PI);\n            ctx.stroke();\n        }\n\n        function drawVertexCircle(ctx, x, y, size, width, borderColor, color, fontFamily, fontSize, content, label, labelSize, labelColor, labelBackgroundColor) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.arc(x, y, size, 0, 2 * Math.PI);\n            ctx.fillStyle = color;\n            ctx.fill();\n            ctx.strokeStyle = borderColor;\n            ctx.lineWidth = width;\n            ctx.stroke();\n            ctx.font = fontSize + \" \" + fontFamily;\n            ctx.fillStyle = (0,_colors_js__WEBPACK_IMPORTED_MODULE_0__.hsvColor)(color).v >= 0.6 ? \"black\" : \"white\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            content = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.render)(content);\n            ctx.fillText(content, x, y);\n            if (label !== undefined) {\n                label = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.render)(label);\n                ctx.font = labelSize + \" \" + fontFamily;\n                ctx.fillStyle = labelColor;\n\n                const x0 = x + size + 5, y0 = y - size;\n\n                if (labelBackgroundColor != null) {\n                    const padding = 2;\n                    const textWidth = ctx.measureText(label).width + padding + 2;\n                    const textHeight = parseInt(labelSize) + padding;\n                    ctx.globalAlpha = 0.8;\n                    ctx.fillStyle = labelBackgroundColor;\n                    ctx.fillRect(x0 - padding, y0 - textHeight / 2, textWidth, textHeight);\n                    ctx.globalAlpha = 1;\n                    ctx.lineWidth = 1;\n                    ctx.strokeStyle = labelColor;\n                    ctx.strokeRect(x0 - padding, y0 - textHeight / 2, textWidth, textHeight);\n                }\n                \n                ctx.textAlign = \"left\";\n                ctx.textBaseline = \"middle\";\n                ctx.fillStyle = labelColor;\n                ctx.fillText(label, x0, y0);\n            }\n\t    ctx.restore();\n        }\n\n        const self = this;\n        function drawEdge(ctx, edge, css, vertexCSS1, vertexCSS2) {\n            const [vertex1, vertex2] = edge;\n            if (css == undefined)\n                css = self.CSS.edge;\n\n            if (\"show\" in css && !css.show)\n                return;\n            \n            if (vertexCSS1 == undefined)\n                vertexCSS1 = self.CSS.vertex;\n            if (vertexCSS2 == undefined)\n                vertexCSS2 = self.CSS.vertex;\n\n\t    const width = \"width\" in css ? css.width : self.CSS.edge.width;\n\t    const lineStyle = \"lineStyle\" in css ? css.lineStyle : self.CSS.edge.lineStyle;\n\t    const color = \"color\" in css ? css.color : self.CSS.edge.color;\n\t    const curvature = \"curvature\" in css ? css.curvature : self.CSS.edge.curvature;\n            const label = self.getEdgeLabel(edge);\n\t    const labelPosition = \"labelPosition\" in css ? css.labelPosition : self.CSS.edge.labelPosition;\n\t    const labelBackgroundColor = \"labelBackgroundColor\" in css ? css.labelBackgroundColor : self.CSS.edge.labelBackgroundColor;\n            \n            if (vertex1 != vertex2) {\n                const [x1, y1] = self.vertexPosition[vertex1];\n                const [x2, y2] = self.vertexPosition[vertex2];\n                const vertexSize1 = \"size\" in vertexCSS1 ? vertexCSS1[\"size\"] : self.CSS.vertex.size;\n                const vertexSize2 = \"size\" in vertexCSS2 ? vertexCSS2[\"size\"] : self.CSS.vertex.size;\n                drawEdgeLine(ctx, x1, y1, x2, y2, width, color, lineStyle, self.graph.directed, label, labelBackgroundColor, labelPosition, curvature, vertexSize1, vertexSize2);\n            } else {\n                const [x, y] = self.vertexPosition[vertex1];\n                const vertexSize =  \"size\" in vertexCSS1 ? vertexCSS1[\"size\"] : self.CSS.vertex.size;\n                drawEdgeLoop(ctx, x, y, width, color, label, vertexSize);\n            }\n        }\n\n        function drawVertex(ctx, vertex, css) {\n            if (css == undefined)\n                css = self.CSS.vertex;\n            if (\"show\" in css && !css.show)\n                return;\n            const [x, y] = self.vertexPosition[vertex];\n\t    const color = \"color\" in css ? css.color : self.CSS.vertex.color;\n\t    const size = \"size\" in css ? css.size : self.CSS.vertex.size;\n\t    const width = \"width\" in css ? css.width : self.CSS.vertex.width;\n\t    const borderColor = \"borderColor\" in css ? css.borderColor : self.CSS.vertex.borderColor;\n            const fontFamily = \"fontFamily\" in css ? css.fontFamily : self.CSS.vertex.fontFamily;\n            const fontSize = \"fontSize\" in css ? css.fontSize : self.CSS.vertex.fontSize;\n            const label = self.vertexLabels[vertex];\n            const numerationStyle = \"numerationStyle\" in css ? css.numerationStyle : self.CSS.vertex.numerationStyle;\n            const content = self.getVertexContent(vertex, numerationStyle);\n            const labelSize = \"labelSize\" in css ? css.labelSize : self.CSS.vertex.labelSize;\n            const labelColor = \"labelColor\" in css ? css.labelColor : self.CSS.vertex.labelColor;\n            const labelBackgroundColor = \"labelBackgroundColor\" in css ? css.labelBackgroundColor : self.CSS.vertex.labelBackgroundColor;\n            \n            drawVertexCircle(ctx, x, y, size, width, borderColor, color, fontFamily, fontSize, content, label, labelSize, labelColor, labelBackgroundColor);\n        }\n\n        const ctx = this.canvas.ctx();\n        ctx.clearRect(0, 0, this.canvas.width(), this.canvas.height());\n\n        // draw edges that are not in focus and not selected\n        if (this.drawEdges) {\n            this.graph.getEdges().forEach(edge => {\n            if (!Graph.equalEdges(this.focusEdge, edge) && !this.isSelectedEdge(edge)) {\n                    const edgeCSS = this.getEdgeCSS(edge);\n                    const [v1, v2] = edge;\n                    const vertexCSS1 = this.getVertexCSS(v1);\n                    const vertexCSS2 = this.getVertexCSS(v2);\n                    drawEdge(ctx, edge, edgeCSS, vertexCSS1, vertexCSS2);\n                }\n            });\n\n            // draw selected edges\n            this.selectedEdges.forEach(edge => {\n                const css = {...this.getEdgeCSS(edge)};\n                for (const property in this.CSS.selectedEdge)\n                    css[property] = this.CSS.selectedEdge[property];\n                const [v1, v2] = edge;\n                const vertexCSS1 = this.getVertexCSS(v1);\n                const vertexCSS2 = this.getVertexCSS(v2);\n                drawEdge(ctx, edge, css, vertexCSS1, vertexCSS2);\n            });\n\n            // draw focus edge\n            if (this.focusEdge != undefined) {\n                const css = {...this.getEdgeCSS(this.focusEdge)};\n                for (const property in this.CSS.focusEdge)\n                    css[property] = this.CSS.focusEdge[property];\n                const [v1, v2] = this.focusEdge;\n                const vertexCSS1 = this.getVertexCSS(v1);\n                const vertexCSS2 = this.getVertexCSS(v2);\n                drawEdge(ctx, this.focusEdge, css, vertexCSS1, vertexCSS2);\n            }\n        }\n\n        if (this.drawVertices) {\n            // draw vertices that are not in focus\n            for (let vertex = 0; vertex < this.numVertices(); vertex++)\n                if (vertex != this.focusVertex || !this.drawFocusVertex) {\n                    const css = this.vertexCSS[vertex] ? this.vertexCSS[vertex] : this.CSS.vertex;\n                    drawVertex(ctx, vertex, css);\n                }\n        \n            // draw focus vertex\n            if (this.drawFocusVertex && this.focusVertex != undefined) {\n                const css = {...this.getVertexCSS(this.focusVertex)};\n                for (const property in this.CSS.focusVertex)\n                    css[property] = this.CSS.focusVertex[property];\n                drawVertex(ctx, this.focusVertex, css);\n            }\n        \n            // draw selected vertices\n            this.selectedVertices.forEach(vertex => {\n                const css = {...this.getVertexCSS(vertex)};\n                for (const property in this.CSS.selectedVertex)\n                    css[property] = this.CSS.selectedVertex[property];\n                drawVertex(ctx, vertex, css)\n            });\n        }\n    }\n\n    onVertexEvent(event, handler) {\n        const self = this;\n        this.canvas.addEventListener(event, function(e) {\n            const vertex = self.vertexOn(e.offsetX, e.offsetY);\n            if (vertex != undefined)\n                handler(vertex, e);\n        });\n    }\n\n    singleClick(handler) {\n        return function() {\n            this.isSingleClick = true;\n            setTimeout(() => {\n                if (this.isSingleClick)\n                    handler(...arguments);\n            }, 250);\n        }\n    }\n\n    doubleClick(handler) {\n        return function() {\n            this.isSingleClick = false;\n            handler(...arguments);\n        }\n    }\n                            \n    onVertexClick(handler) {\n        this.onVertexEvent(\"click\", this.singleClick(handler).bind(this));\n    }\n\n    onVertexDblClick(handler) {\n        this.onVertexEvent(\"dblclick\", this.doubleClick(handler).bind(this));\n    }\n\n    onVertexMouseover(handler) {\n        this.onVertexEvent(\"mousemove\", handler);\n    }\n\n    onVertexEnter(handler) {\n        const self = this;\n        this.canvas.addEventListener(\"mousemove\", function(e) {\n            const vertex = self.vertexOn(e.offsetX, e.offsetY);\n            if (self.vertexEnter == undefined && vertex != undefined)\n                handler(vertex, e);\n            self.vertexEnter = vertex;\n        });\n    }\n\n    onVertexLeave(handler) {\n        const self = this;\n        this.canvas.addEventListener(\"mousemove\", function(e) {\n            const vertex = self.vertexOn(e.offsetX, e.offsetY);\n            if (self.vertexLeave != undefined && self.vertexLeave != vertex)\n                handler(self.vertexLeave, e);\n            self.vertexLeave = vertex;\n        });\n    }\n\n    onEdgeEvent(event, handler) {\n        const self = this;\n        this.canvas.addEventListener(event, function(e) {\n            const edge = self.edgeOn(e.offsetX, e.offsetY);\n            if (edge != undefined)\n                handler(edge);\n        });\n    }\n\n    onEdgeClick(handler) {\n        this.onEdgeEvent(\"click\", handler);\n    }\n\n    onEdgeDblClick(handler) {\n        this.onEdgeEvent(\"dblclick\", handler);\n    }\n\n    selectVerticesOnClick() {\n        var self = this;\n        this.onVertexClick(function(vertex) {\n            self.toggleSelectVertex(vertex);\n        });\n    }\n\n    selectEdgesOnClick() {\n        const self = this;\n        this.onEdgeClick(function(edge) {\n            self.toggleSelectEdge(edge);\n        });\n    }\n\n    selectVerticesOnDblClick() {\n        const self = this;\n        this.onVertexDblClick(function(vertex) {\n            self.toggleSelectVertex(vertex);\n        });\n    }\n\n    selectEdgesOnDblClick() {\n        const self = this;\n        this.onEdgeDblClick(function(edge) {\n            self.toggleSelectEdge(edge);\n        });\n    }\n\n    showFocusVertex() {\n        const self = this;\n        this.canvas.addEventListener(\"mousemove\", function(e) {\n            self.focusVertexOn(e.offsetX, e.offsetY);\n        });\n        this.drawFocusVertex = true;\n    }\n\n    showFocusEdge() {\n        const self = this;\n        this.canvas.addEventListener(\"mousemove\", function(e) {\n            self.focusEdgeOn(e.offsetX, e.offsetY);\n        });\n    }\n\n    dragFocusVertex() {\n        const self = this;\n        let mouseDown = false;\n        let downTime;\n        this.canvas.addEventListener(\"mousedown\", function(e) {\n            if (e.button == 0) {\n                mouseDown = true;\n                downTime = Date.now();\n            }\n        });\n        \n        this.canvas.addEventListener(\"mousemove\", function(e) {\n            if (mouseDown && Date.now() - downTime > 100)\n                self.moveFocusVertex(e.offsetX, e.offsetY);\n        });\n\n        this.canvas.addEventListener(\"mouseup\", function(e) {\n            mouseDown = false;\n        });\n\n        this.canvas.addEventListener(\"mousemove\", function(e) {\n            self.focusVertexOn(e.offsetX, e.offsetY);\n        });\n    }\n\n    orderVertices(start, vertex) {\n        if (this.getVertexLabel(vertex) == undefined)\n            this.setVertexLabel(vertex, this.numLabeledVertices() + start);\n        else if (this.getVertexLabel(vertex) == this.numLabeledVertices() + start - 1) {\n            this.removeVertexLabel(vertex);\n        }\n    }\n\n    orderVerticesDblClick(start=0) {\n        this.onVertexDblClick(vertex => { this.orderVertices(start, vertex); });\n    }\n\n    orderVerticesClick(start=0) {\n        this.onVertexClick(vertex => { this.orderVertices(start, vertex); });\n    }\n\n    orderEdges(edge, start, showLabel, onAdd, onRemove, unique) {\n        if (!unique || !Graph.inEdgeSet(edge, this.edgeOrder, this.graph.directed)) {\n            this.edgeOrder.push(edge);\n            if (showLabel)\n                this.setEdgeLabel(edge, start + this.edgeOrder.length - 1);\n            onAdd(edge);\n        } else if (Graph.equalEdges(this.edgeOrder[this.edgeOrder.length - 1], edge)) {\n            this.edgeOrder.pop();\n            if (showLabel)\n                this.setEdgeLabel(edge, undefined);\n            onRemove(edge);\n        }\n    }\n\n    orderEdgesClick({start=0, showLabel=true, onAdd = (edge => {}), onRemove = (edge => {}), unique=true} = {}) {\n        this.edgeOrder = [];\n        this.onEdgeClick(edge => { this.orderEdges(edge, start, showLabel, onAdd, onRemove, unique); });\n    }\n\n    orderEdgesDblClick({start=0, showLabel=true, onAdd = (edge => {}), onRemove = (edge => {}), unique=true} = {}) {\n        this.edgeOrder = [];\n        this.onEdgeDblClick(edge => { this.orderEdges(edge, start, showLabel, onAdd, onRemove, unique); });\n    }\n    \n    vertexInput(vertex, callback) {\n        const input = document.createElement(\"input\");\n        input.type = \"text\";\n        input.style.position = 'fixed';\n        const [x, y] = this.vertexPosition[vertex];\n        const canvasRect = this.canvas.getBoundingClientRect();\n        input.style.textAlign = \"center\";\n        input.style.width = 30 + \"px\";\n        input.style.height = 20 + \"px\";\n        input.style.left = canvasRect.left + x - 18 + 'px';\n        input.style.top = canvasRect.top + y - 12 + 'px';\n        document.body.appendChild(input);\n        input.focus();\n        input.onblur = function() {\n            callback(vertex, input.value);\n            document.body.removeChild(input);\n        }\n    }\n\n    vertexInputContent(vertex) {\n        this.vertexInput(vertex, ((vertex, value) => { if (value) this.setVertexContent(vertex, value); }).bind(this));\n    }\n\n    vertexInputLabel(vertex) {\n        this.vertexInput(vertex, ((vertex, value) => { if (value) this.setVertexLabel(vertex, value); }).bind(this));\n    }\n\n    editValueOnClick() {\n        this.onVertexClick(this.vertexInputContent.bind(this));\n    }\n\n    editValueOnDblClick() {\n        this.onVertexDblClick(this.vertexInputContent.bind(this));\n    }\n\n    editLabelOnClick() {\n        this.onVertexClick(this.vertexInputLabel.bind(this));\n    }\n\n    editLabelOnDblClick() {\n        this.onVertexDblClick(this.vertexInputLabel.bind(this));\n    }\n    \n    setCSS() {\n        this.CSS = {\n            edge: {\n                width: 1,\n                color: \"black\",\n                curvature: 0,\n                labelPosition: 0.5,\n                lineStyle: \"solid\",\n                show: true\n            },\n            \n            vertex: {\n                color: \"white\",\n                size: 15,\n                width: 1,\n                borderColor: \"black\",\n                fontFamily: \"Arial\",\n                fontSize: \"15px\",\n                labelSize: \"13px\",\n                labelColor: \"black\",\n                labelBackgroundColor: null,\n                numerationStyle: \"1\",\n                show: true\n            },\n\n            focusEdge: {\n                color: \"#bbbbbb\"\n            },\n\n            focusVertex: {\n                color: \"#cccccc\"\n            },\n            \n            selectedVertex: {\n                color: \"#9999ff\"\n            },\n\n            selectedEdge: {\n                width: 2,\n                color: \"red\"\n            }\n        }\n    }\n}\n\nclass CommandSetEdgeCSS {\n    constructor(graphDrawing, edge, css) {\n        this.graphDrawing = graphDrawing;\n        this.edge = edge;\n        this.css = css;\n    }\n\n    doCommand() {\n        this.undo = {...this.graphDrawing.getEdgeCSS(this.edge)};\n        this.graphDrawing.setEdgeCSS(this.edge, this.css);\n    }\n\n    undoCommand() {\n        this.graphDrawing.removeEdgeCSS(this.edge);\n        if (this.undo != undefined)\n            this.graphDrawing.setEdgeCSS(this.edge, this.undo);\n    }\n}\n\nclass CommandResetAllVertexCSS {\n    constructor(graphDrawing) {\n        this.graphDrawing = graphDrawing;\n    }\n\n    doCommand() {\n        this.undo = new Array(this.graphDrawing.numVertices());\n        for (let v = 0; v < this.graphDrawing.numVertices(); v++) {\n            this.undo[v] = this.graphDrawing.getVertexCSS(v);\n            this.graphDrawing.removeVertexCSS(v);\n        }\n    }\n\n    undoCommand() {\n        for (let v = 0; v < this.graphDrawing.numVertices(); v++)\n            this.graphDrawing.setVertexCSS(v, this.undo[v]);\n    }\n}\n\nclass CommandSetVertexCSS {\n    constructor(graphDrawing, vertex, css) {\n        this.graphDrawing = graphDrawing;\n        this.vertex = vertex;\n        this.css = css;\n    }\n\n    doCommand() {\n        this.undo = {...this.graphDrawing.getVertexCSS(this.vertex)};\n        this.graphDrawing.setVertexCSS(this.vertex, this.css);\n    }\n\n    undoCommand() {\n        this.graphDrawing.removeVertexCSS(this.vertex);\n        this.graphDrawing.setVertexCSS(this.vertex, this.undo);\n    }\n}\n\nclass CommandSetVertexLabel {\n    constructor(graphDrawing, vertex, label) {\n        this.graphDrawing = graphDrawing;\n        this.vertex = vertex;\n        this.label = label;\n    }\n\n    doCommand() {\n        this.undo = this.graphDrawing.getVertexLabel(this.vertex);\n        this.graphDrawing.setVertexLabel(this.vertex, this.label);\n    }\n\n    undoCommand() {\n        this.graphDrawing.setVertexLabel(this.vertex, this.undo);\n    }\n}\n\nclass CommandSetVertexContent {\n    constructor(graphDrawing, vertex, content) {\n        this.graphDrawing = graphDrawing;\n        this.vertex = vertex;\n        this.content = content;\n    }\n\n    doCommand() {\n        this.undo = this.graphDrawing.getVertexContent(this.vertex);\n        this.graphDrawing.setVertexContent(this.vertex, this.content);\n    }\n\n    undoCommand() {\n        this.graphDrawing.setVertexContent(this.vertex, this.undo);\n    }\n}\n\n\n\nclass GraphCommands extends _commands_js__WEBPACK_IMPORTED_MODULE_3__.Commands {\n    constructor(commands) {\n        super(commands);\n    }\n}\n\n\n//# sourceURL=webpack://algoedu.js/./components/graph.js?");

/***/ }),

/***/ "./components/union_find.js":
/*!**********************************!*\
  !*** ./components/union_find.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnionFind: () => (/* binding */ UnionFind)\n/* harmony export */ });\n// Union-Find data structure implementation\nclass UnionFind {\n    constructor(size) {\n        this.parent = Array(size).fill().map((_, index) => index);\n    }\n\n    find(node) {\n        if (this.parent[node] === node)\n            return node;\n        this.parent[node] = this.find(this.parent[node]);\n        return this.parent[node];\n    }\n\n    union(nodeA, nodeB) {\n        const rootA = this.find(nodeA);\n        const rootB = this.find(nodeB);\n        if (rootA !== rootB) {\n            this.parent[rootA] = rootB;\n            return true; // Nodes were merged\n        }\n        return false; // Nodes were already connected\n    }\n}\n\n\n//# sourceURL=webpack://algoedu.js/./components/union_find.js?");

/***/ }),

/***/ "./components/util.js":
/*!****************************!*\
  !*** ./components/util.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   render: () => (/* binding */ render),\n/* harmony export */   shuffle: () => (/* binding */ shuffle)\n/* harmony export */ });\nfunction shuffle(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n}\n\nfunction random(a, b) {\n    if (b === undefined) {\n        b = a;\n        a = 0;\n    }\n    return a + Math.floor(Math.random() * (b - a + 1));\n}\n\nfunction render(text) {\n    if (text === Infinity)\n        return \"\";\n    else if (text === undefined)\n        return \"?\";\n    else\n        return text;\n}\n\n\n//# sourceURL=webpack://algoedu.js/./components/util.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./components/graph.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
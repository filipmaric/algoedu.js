/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Graph"] = factory();
	else
		root["Graph"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./components/colors.js":
/*!******************************!*\
  !*** ./components/colors.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getOpacity\": () => (/* binding */ getOpacity),\n/* harmony export */   \"hsvColor\": () => (/* binding */ hsvColor),\n/* harmony export */   \"parseRGB\": () => (/* binding */ parseRGB),\n/* harmony export */   \"rgb2hsv\": () => (/* binding */ rgb2hsv),\n/* harmony export */   \"rgbColor\": () => (/* binding */ rgbColor),\n/* harmony export */   \"setOpacity\": () => (/* binding */ setOpacity)\n/* harmony export */ });\nconst ctx = document.createElement(\"canvas\").getContext(\"2d\");\n\n// input: r,g,b in [0,1], out: h in [0,360) and s,v in [0,1]\nfunction rgb2hsv(r, g, b) {\n    let v=Math.max(r,g,b), c=v-Math.min(r,g,b);\n    let h= c && ((v==r) ? (g-b)/c : ((v==g) ? 2+(b-r)/c : 4+(r-g)/c)); \n    return [60*(h<0?h+6:h), v&&c/v, v];\n}\n\n// read RGB from rgb or rgba string\nfunction parseRGB(str) {\n    const m = str.match(/^rgba?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*(\\d+([.]\\d*)?))?\\s*\\)$/i);\n    return m ? {\n        r: parseFloat(m[1]),\n        g: parseFloat(m[2]),\n        b: parseFloat(m[3])\n    } : null;\n}\n\n// convert color in any format to rgb\nfunction rgbColor(str){\n    function hexToRGB(hex) {\n        const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n        return result ? {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16)\n        } : null;\n    }\n\n    ctx.fillStyle = str;\n    const color = ctx.fillStyle;\n    if (color[0] == '#')\n        return hexToRGB(color);\n    else\n        return parseRGB(color);\n}\n\nfunction hsvColor(str) {\n    const rgb = rgbColor(str);\n    const hsv = rgb2hsv(rgb.r / 255, rgb.g / 255, rgb.b / 255);\n    return {h: hsv[0], s: hsv[1], v: hsv[2]};\n}\n\n// extract opacity from color string\nfunction getOpacity(color) {\n    const defaultOpacity = 1;\n    \n    if (!color)\n        return defaultOpacity;\n    const m = color.match(/^rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+([.]\\d*)?)\\s*\\)$/i);\n    return parseFloat(m ? m[4] : defaultOpacity);\n}\n\n// set opacity to color string\nfunction setOpacity(color, o) {\n    const rgb = rgbColor(color);\n    return \"rgba(\" + rgb.r + \", \" + rgb.g + \", \" + rgb.b + \", \" + o + \")\";\n}\n\n\n//# sourceURL=webpack://algoedu.js/./components/colors.js?");

/***/ }),

/***/ "./components/commands.js":
/*!********************************!*\
  !*** ./components/commands.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Commands\": () => (/* binding */ Commands)\n/* harmony export */ });\nclass Commands {\n    constructor(commands) {\n        this.commands = commands;\n        this.current = 0;\n    }\n\n    reset() {\n        while (this.inProgress()) {\n            this.current--;\n            this.undoCurrentCommand();\n        }\n    }\n\n    inProgress() {\n        return this.current > 0;\n    }\n\n    done() {\n        return this.current >= this.commands.length;\n    }\n\n    next() {\n        if (this.done())\n            return false;\n        this.doCurrentCommand();\n        this.current++;\n        return true;\n    }\n\n    doCurrentCommand() {\n        if (Array.isArray(this.commands[this.current]))\n            this.commands[this.current].forEach(command => command.doCommand());\n        else\n            this.commands[this.current].doCommand();\n    }\n\n    undoCurrentCommand() {\n        if (Array.isArray(this.commands[this.current]))\n            this.commands[this.current].slice().reverse().forEach(command => command.undoCommand());\n        else\n            this.commands[this.current].undoCommand();\n    }\n\n    previous() {\n        if (this.current == 0)\n            return false;\n        --this.current;\n        this.undoCurrentCommand();\n        return true;\n    }\n\n    run() {\n        while (!this.done()) {\n            this.doCurrentCommand();\n            this.current++;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://algoedu.js/./components/commands.js?");

/***/ }),

/***/ "./components/graph.js":
/*!*****************************!*\
  !*** ./components/graph.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BinaryTree\": () => (/* binding */ BinaryTree),\n/* harmony export */   \"CommandResetAllVertexCSS\": () => (/* binding */ CommandResetAllVertexCSS),\n/* harmony export */   \"CommandSetEdgeCSS\": () => (/* binding */ CommandSetEdgeCSS),\n/* harmony export */   \"CommandSetVertexCSS\": () => (/* binding */ CommandSetVertexCSS),\n/* harmony export */   \"CommandSetVertexContent\": () => (/* binding */ CommandSetVertexContent),\n/* harmony export */   \"CommandSetVertexLabel\": () => (/* binding */ CommandSetVertexLabel),\n/* harmony export */   \"Graph\": () => (/* binding */ Graph),\n/* harmony export */   \"GraphCommands\": () => (/* binding */ GraphCommands),\n/* harmony export */   \"GraphDrawing\": () => (/* binding */ GraphDrawing),\n/* harmony export */   \"WeightedGraph\": () => (/* binding */ WeightedGraph)\n/* harmony export */ });\n/* harmony import */ var _colors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colors.js */ \"./components/colors.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./components/util.js\");\n/* harmony import */ var _union_find_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./union_find.js */ \"./components/union_find.js\");\n/* harmony import */ var _commands_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./commands.js */ \"./components/commands.js\");\n\n\n\n\nclass Graph {\n    constructor(n=0, directed=true) {\n        this.directed = directed;\n        this.weighted = false;\n        this.emptyGraph(n);\n    }\n\n    numVertices() {\n        return this.neighbours.length;\n    }\n\n    addVertex() {\n        this.neighbours.push([]);\n        return this.numVertices() - 1;\n    }\n\n    addEdge(i, j) {\n        this.neighbours[i].push(j);\n        if (!this.directed)\n            this.neighbours[j].push(i);\n    }\n\n    removeEdge(i, j) {\n        this.neighbours[i] = this.neighbours[i].filter(item => item != j);\n        if (!this.directed)\n            this.neighbours[j] = this.neighbours[j].filter(item => item != i);\n    }\n\n    hasEdge(i, j) {\n        return this.neighbours[i].includes(j);\n    }\n\n    getEdges() {\n        if (this.directed)\n            return this.neighbours.map((ns, v) => ns.map(n => [v, n])).flat(1);\n        else\n            return this.neighbours.map((ns, v) => ns.map(n => [v, n])).flat(1).filter(edge => edge[0] <= edge[1]);\n    }\n\n    getNeighbours(i) {\n        return this.neighbours[i];\n    }\n\n    emptyGraph(n) {\n        this.neighbours = Array.from({length: n}, () => []);\n    }\n\n    sortNeighbours() {\n        for (let i = 0; i < this.neighbours.length; i++)\n            this.neighbours[i].sort((a, b) => a-b);\n    }\n    \n    fullGraph(n) {\n        if (n === undefined)\n            n = this.numVertices();\n        this.emptyGraph(n);\n        for (let i = 0; i < n; i++)\n            for (let j = 0; j < n; j++)\n                if (i < j)\n                    this.addEdge(i, j);\n        this.sortNeighbours();\n    }\n    \n    randomGraph(n, prob=0.25) {\n        if (n === undefined)\n            n = this.numVertices();\n        \n        this.emptyGraph(n);\n        for (let i = 0; i < n; i++) {\n            for (let j = 0; j < n; j++)\n                if (i != j && (i < j || !this.hasEdge(j, i)) && Math.random() < (i == 0 ? 2*prob : prob))\n                    this.addEdge(i, j);\n            if (this.getNeighbours(i).length == 0) {\n                let j;\n                do {\n                    j = Math.floor(Math.random() * n);\n                } while (j == i);\n                this.addEdge(i, j);\n            }\n        }\n        this.sortNeighbours();\n    }\n\n    // random tree with n vertices and edges chosen from the given set of edges\n    static randomTree(n, edges) {\n        const treeEdges = [];\n        const unionFind = new _union_find_js__WEBPACK_IMPORTED_MODULE_2__.UnionFind(n);\n\n        if (edges === undefined) {\n            edges = [];\n            for (let i = 0; i < n - 1; i++) {\n                for (let j = i + 1; j < n; j++) {\n                    edges.push([i, j]);\n                }\n            }            \n        }\n\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.shuffle)(edges);\n\n        for (const [nodeA, nodeB] of edges) {\n            if (unionFind.union(nodeA, nodeB))\n                treeEdges.push([nodeA, nodeB]);\n            if (treeEdges.length == n - 1)\n                break;\n        }\n        return treeEdges;\n    }\n\n    static latticeGraphEdges(m, n, diagonals) {\n        function vertex(i, j) {\n            return i * n + j;\n        }\n\n        const edges = [];\n\n        for (let i = 0; i < m; i++)\n            for (let j = 1; j < n; j++) {\n                const edge = [vertex(i, j-1), vertex(i, j)];\n                edges.push(edge);\n            }\n\n        for (let j = 0; j < n; j++)\n            for (let i = 1; i < m; i++) {\n                const edge = [vertex(i-1, j), vertex(i, j)];\n                edges.push(edge);\n            }\n\n        if (diagonals) {\n            for (let i = 1; i < m; i++)\n                for (let j = 1; j < n; j++) {\n                    const edge = [vertex(i-1, j-1), vertex(i, j)];\n                    edges.push(edge);\n                }\n\n            for (let i = 0; i < m-1; i++)\n                for (let j = 1; j < n; j++) {\n                    const edge = [vertex(i, j), vertex(i+1, j-1)];\n                    edges.push(edge);\n                }\n        }\n        return edges;\n    }\n\n    static orientTree(edges, root) {\n        function dfs(node) {\n            visited.push(node);\n            const nodeEdges = edges.filter(edge => edge.includes(node));\n            const neighbours = nodeEdges.map(edge => edge.filter(x => x != node)).flat(1);\n            neighbours.forEach(neighbour => {\n                if (!visited.includes(neighbour)) {\n                    orientedEdges.push([node, neighbour]);\n                    dfs(neighbour);\n                }\n            });\n        }\n        const visited = [];\n        const orientedEdges = [];\n        dfs(root);\n        return orientedEdges;\n    }\n\n    latticeGraph(m, n) {\n        this.emptyGraph(m * n);\n        for (const [nodeA, nodeB] of Graph.latticeGraphEdges(m, n, false))\n            this.addEdge(nodeA, nodeB);\n        this.sortNeighbours();\n    }\n\n    randomLatticeGraph(m, n, numEdges) {\n        this.emptyGraph(m * n);\n\n        const edges = Graph.latticeGraphEdges(m, n, true);\n\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.shuffle)(edges);\n        for (let i = 0; i < numEdges && i < edges.length; i++)\n            this.addEdge(...edges[i]);\n        \n        this.sortNeighbours();\n    }\n\n    randomConnectedLatticeGraph(m, n, numEdges) {\n        this.emptyGraph(m * n);\n        const edges = Graph.latticeGraphEdges(m, n, true);\n        const tree = Graph.orientTree(Graph.randomTree(this.numVertices(), edges), 0);\n        const eqEdges = (edge1, edge2) => (edge1[0] == edge2[0] && edge1[1] == edge2[1]) ||\n                                          (edge1[0] == edge2[1] && edge1[1] == edge2[0]);\n        const remainingEdges = edges.filter(edge => !tree.some(edge1 => eqEdges(edge, edge1)));\n        tree.forEach(edge => this.addEdge(...edge));\n        for (let i = 0; i < numEdges - tree.length && i < remainingEdges.length; i++)\n            this.addEdge(...remainingEdges[i]);\n        this.sortNeighbours();\n    }\n    \n    static adjacencyLists(n, edges, reverse=false) {\n        const neighbours = [...Array(n)].map(i => []);\n        edges.forEach(edge => {\n            let [a, b] = edge;\n            if (reverse)\n                [a, b] = [b, a];\n            neighbours[a].push(b);\n        });\n        return neighbours;\n    }\n\n    dfsPrePost(startVertex, preprocess, postprocess) {\n        function dfsRecPrePost(vertex) {\n            if (visited[vertex])\n                return;\n            visited[vertex] = true;\n            preprocess(vertex);\n            this.neighbours[vertex].forEach(neighbour => {\n                if (neighbour != null && !visited[neighbour])\n                    this.dfsRec(neighbour, visited, trace);\n            });\n            postprocess(vertex);\n        }\n        const visited = new Array(this.numVertices()).fill(false);\n        dfsRecPrePost(startVertex);\n    }\n\n    dfsRec(vertex, visited, trace) {\n        if (visited[vertex])\n            return;\n        visited[vertex] = true;\n        this.neighbours[vertex].forEach(neighbour => {\n            if (neighbour != null && !visited[neighbour]) {\n                trace.push([vertex, neighbour]);\n                this.dfsRec(neighbour, visited, trace);\n                trace.push([vertex]);\n            }\n        });\n    }\n\n    dfs(vertex=0) {\n        const visited = new Array(this.numVertices()).fill(false);\n        const trace = []\n        this.dfsRec(vertex, visited, trace);\n        return trace;\n    }\n\n    dfsTree(vertex=0) {\n        return this.dfs(vertex).filter(item => item.length == 2);\n    }\n\n    dfsParent(vertex=0) {\n        const parent = new Array(this.numVertices()).fill(-1);\n        this.dfsTree(vertex).forEach(edge => {\n            const [from, to] = edge;\n            parent[to] = from;\n        });\n        return parent;\n    }\n\n    dfsOrder(vertex=0) {\n        const treeEdges = this.dfsTree(0);\n        let order = treeEdges.map(edge => edge[1]);\n        order.unshift(treeEdges[0][0]);\n        return order;\n    }\n    \n    dfsForrest(roots) {\n        const visited = new Array(this.numVertices()).fill(false);\n        const trace = [];\n        if (roots === undefined) {\n            for (let i = 0; i < this.numVertices(); i++)\n                if (!visited[i])\n                    this.dfsRec(i, visited, trace);\n        } else {\n            roots.forEach(i => {\n                if (!visited[i])\n                    this.dfsRec(i, visited, trace);\n            });\n        }\n        return trace.filter(item => item.length == 2);\n    }\n\n    dfsPreorderNumeration(vertex=0) {\n        const dfsTrace = this.dfs(vertex);\n        const preorder = new Array(this.numVertices()).fill(-1);\n        if (dfsTrace.length == 0)\n            return preorder;\n        let preorderNum = 0;\n        const start = dfsTrace[0][0];\n        preorder[start] = preorderNum++;\n        dfsTrace.forEach(data => {\n            if (data.length == 2) {\n                const [from, to] = data;\n                preorder[to] = preorderNum++;\n            }\n        });\n        return preorder;\n    }\n\n    dfsPostorderNumeration(vertex=0) {\n        const dfsTrace = this.dfs(vertex);\n        const postorder = new Array(this.numVertices()).fill(-1);\n        if (dfsTrace.length == 0)\n            return postorder;\n        let postorderNum = 0;\n        const start = dfsTrace[0][0];\n        const stack = [];\n        dfsTrace.forEach(data => {\n            if (data.length == 2) {\n                const [from, to] = data;\n                stack.push(to);\n            } else if (data.length == 1) {\n                const to = stack.pop();\n                postorder[to] = postorderNum++;\n            }\n        });\n        postorder[start] = postorderNum++;\n        return postorder;\n    }\n\n    dfsLowlink(vertex = 0) {\n        const lowlink = new Array(this.numVertices()).fill(-1);\n        const parent = new Array(this.numVertices()).fill(-1);\n        let preorderNum = 0;\n        const preorder = new Array(this.numVertices()).fill(-1);\n        const order = [];\n\n        const self = this;\n        function dfsRec(vertex) {\n            order.push(vertex);\n            preorder[vertex] = lowlink[vertex] = preorderNum++;\n            self.neighbours[vertex].forEach(neighbour => {\n                if (preorder[neighbour] == -1) {\n                    parent[neighbour] = vertex;\n                    dfsRec(neighbour);\n                    if (lowlink[neighbour] < lowlink[vertex])\n                        lowlink[vertex] = lowlink[neighbour];\n                } else if (neighbour != parent[vertex]) {\n                    if (preorder[neighbour] < lowlink[vertex])\n                        lowlink[vertex] = preorder[neighbour];\n                }\n            });\n        }\n\n        dfsRec(vertex);\n        return lowlink.map(l => order[l]);\n    }\n\n    bridges() {\n        if (this.directed)\n            throw \"Bridges are not yet implemented for directed graphs\";\n        const lowlink = graph.dfsLowlink(0);\n        const preorder = graph.dfsPreorderNumeration(0);\n        const bridges = this.dfsTree(0).filter(edge => {\n            const [from, to] = edge;\n            return preorder[from] < preorder[to] &&\n                   preorder[lowlink[to]] > preorder[from];\n        });\n        return bridges;\n    }\n\n    articulationPoints() {\n        if (this.directed)\n            throw \"Articulation points are not yet implemented for directed graphs\";\n        const aps = [];\n        const start = 0;\n        const lowlink = graph.dfsLowlink(start);\n        const preorder = graph.dfsPreorderNumeration(start);\n        const dfsTree = graph.dfsTree(start);\n        const treeNeighbours = Graph.adjacencyLists(this.numVertices(), dfsTree);\n        \n        for (let u = 1; u < this.numVertices(); u++) {\n            for (const v of treeNeighbours[u])\n                if (preorder[lowlink[v]] >= preorder[u]) {\n                    aps.push(u);\n                    break;\n                }\n        }\n            \n        return aps;\n    }\n        \n    bfs(vertex) {\n        const self = this;\n        const visited = new Array(this.numVertices()).fill(false);\n        const trace = [];\n        const queue = [];\n        queue.push(vertex);\n        visited[vertex] = true;\n        while (queue.length > 0) {\n            vertex = queue.shift();\n            self.neighbours[vertex].forEach(neighbour => {\n                if (!visited[neighbour]) {\n                    queue.push(neighbour);\n                    visited[neighbour] = true;\n                    trace.push([vertex, neighbour]);\n                }\n            });\n        }\n        return trace;\n    }\n\n    normalizeEdge(edge) {\n        if (!this.directed && edge[0] > edge[1])\n            return [edge[1], edge[0]];\n        return edge;\n    }\n\n    // auxiliary function -- check if two edges are equal\n    static equalEdges(g1, g2) {\n        if (!g1 || !g2)\n            return false;\n        var [a1, b1] = g1;\n        var [a2, b2] = g2;\n        return a1 == a2 && b1 == b2;\n    }\n}\n\nclass WeightedGraph extends Graph {\n    constructor(n=0, directed=true) {\n        super(n)\n        this.weighted = true;\n        this.directed = directed;\n    }\n\n    emptyGraph(n) {\n        super.emptyGraph(n);\n        this.weights = Array.from({length: n}, () => Array(n).fill(undefined));\n    }\n\n    addEdge(i, j, w) {\n        super.addEdge(i, j);\n        this.weights[i][j] = w;\n        if (!this.directed)\n            this.weights[j][i] = w;\n    }\n\n\n    setWeight(i, j, w) {\n        this.weights[i][j] = w;\n        if (!this.directed)\n            this.weights[j][i] = w;\n    }\n\n    getWeight(i, j) {\n        return this.weights[i][j];\n    }\n    \n    getWeightedEdges() {\n        const n = this.numVertices();\n        const edges = [];\n        for (let vertex = 0; vertex < n; vertex++)\n            this.neighbours[vertex].forEach(neighbour => {\n                if (this.directed || vertex < neighbour)\n                    edges.push([this.weights[vertex][neighbour], vertex, neighbour]);\n            });\n        return edges;\n    }\n\n    randomWeights(minWeight, maxWeight) {\n        const n = this.numVertices();\n        for (let i = 0; i < n; i++)\n            for (let j = 0; j < n; j++) {\n                const w = minWeight + Math.floor((maxWeight - minWeight + 1) * Math.random());\n                if (this.hasEdge(i, j))\n                    this.setWeight(i, j, w);\n            }\n    }\n\n    randomGraph(n, minWeight=1, maxWeight=100, prob=0.25) {\n        super.randomGraph(n, prob);\n        this.randomWeights(minWeight, maxWeight);\n    }\n\n    fullGraph(n, minWeight=1, maxWeight=100) {\n        super.fullGraph(n);\n        this.randomWeights(minWeight, maxWeight);\n    }\n\n    latticeGraph(m, n, minWeight=1, maxWeight=100) {\n        super.latticeGraph(m, n);\n        this.randomWeights(minWeight, maxWeight);\n    }\n    \n    dijkstra(vertex=0) {\n        const n = this.numVertices();\n        let numChanges = 0;\n        const vertexOrder = []\n        const table = [];\n        const dist = new Array(n).fill(Infinity);\n        dist[vertex] = 0;\n        table.push([...dist]);\n        \n        const isSolved = new Array(n).fill(false);\n        const parents = [new Array(n).fill(null)];\n        for (let i = 0; i < n; i++) {\n            let min = -1;\n            for (let j = 0; j < n; j++) {\n                if (isSolved[j])\n                    continue;\n                if (min == -1 || dist[j] < dist[min])\n                    min = j;\n            }\n            isSolved[min] = true;\n            vertexOrder.push(min);\n            const minParents  = [...parents[parents.length - 1]];\n            this.neighbours[min].forEach(neighbour => {\n                if (dist[min] + this.weights[min][neighbour] < dist[neighbour]) {\n                    minParents[neighbour] = min;\n                    if (dist[neighbour] < Infinity)\n                        numChanges++;\n                    dist[neighbour] = dist[min] + this.weights[min][neighbour];\n                }\n            });\n            table.push([...dist]);\n\t    parents.push(minParents);\n        }\n        return {dist: dist, vertexOrder: vertexOrder, table: table, parents: parents, numChanges: numChanges};\n    }\n\n    prim() {\n        let mstWeight = 0;\n\tconst mstEdges = [];\n\tlet vertex = 0;\n\tconst vertexOrder = [];\n\tvertexOrder.push(vertex);\n\tlet candidateEdges = [];\n\twhile (vertexOrder.length < this.numVertices()) {\n\t    candidateEdges = candidateEdges.filter(g => g[2] != vertex);\n\t    this.neighbours[vertex].forEach(neighbour => { \n\t\tif (!vertexOrder.includes(neighbour))\n\t\t    candidateEdges.push([this.weights[vertex][neighbour], vertex, neighbour]);\n\t    });\n\t    let minEdge = 0;\n\t    for (let edge = 1; edge < candidateEdges.length; edge++) {\n\t\tif (candidateEdges[edge][0] < candidateEdges[minEdge][0] ||\n                    (candidateEdges[edge][0] == candidateEdges[minEdge][0] &&\n                     candidateEdges[edge][2] < candidateEdges[minEdge][2]))\n\t\t    minEdge = edge;\n\t    }\n\t    vertex = candidateEdges[minEdge][2];\n\t    mstEdges.push(candidateEdges[minEdge]);\n            mstWeight += candidateEdges[minEdge][0];\n\t    candidateEdges.splice(minEdge, 1);\n\t    vertexOrder.push(vertex);\n\t}\n\treturn {vertexOrder: vertexOrder, mstEdges: mstEdges, mstWeight: mstWeight};\n    }\n\n    kruskal() {\n        const n = this.numVertices();\n        const sortedEdges = this.getWeightedEdges().sort((a, b) => {\n            if (a[0] < b[0]) return -1;\n            else if (a[0] > b[0]) return 1;\n            else if (a[1] < b[1]) return -1;\n            else if (a[1] > b[1]) return 1;\n            else return a[2] - b[2];\n        });\n        \n        const color = new Array(n);\n        for (var vertex = 0; vertex < n; vertex++)\n            color[vertex] = vertex;\n        \n        const mstEdges = [];\n        const allEdges = []\n        let mstWeight = 0;\n        for (let i = 0; i < sortedEdges.length; i++) {\n            var [weight, vertexA, vertexB] = sortedEdges[i];\n            if (color[vertexA] != color[vertexB]) {\n                mstEdges.push([weight, vertexA, vertexB]);\n                mstWeight += weight;\n                allEdges.push([vertexA, vertexB, true]);\n            } else\n                allEdges.push([vertexA, vertexB, false]);\n\n            const colorA = color[vertexA], colorB = color[vertexB];\n            for (let vertex = 0; vertex < n; vertex++)\n                if (color[vertex] == colorA)\n                    color[vertex] = colorB;\n        }\n        return {mstWeight: mstWeight, mstEdges: mstEdges, allEdges: allEdges};\n    }\n\n    // FIXME: UNTESTED\n    floydWarshall() {\n\tfunction cloneMatrix(M) {\n\t    const clone = new Array(M.length);\n\t    for (var i = 0; i < M.length; i++)\n\t\tclone[i] = [...M[i]];\n\t    return clone;\n\t}\n\n\tconst n  = this.numVertices();\n\tconst M = new Array(n);\n        const Mp = new Array(n);\n\tfor (let i = 0; i < n; i++) {\n\t    M[i] = new Array(n).fill(Infinity);\n\t    Mp[i] = new Array(n).fill([]);\n\t}\n\n        for (let i = 0; i < n; i++) {\n\t    this.neighbours[i].forEach((j, s) => {\n\t\tM[i][s] = this.weights[i][j];\n\t\tMp[i][s] = [i, s];\n\t    });\n\t    M[i][i] = 0;\n\t}\n        \n\tlet Ms = [cloneMatrix(M)];\n\tlet Mps = [cloneMatrix(Mp)];\n\n\tfor (let k = 0; k < n; k++) {\n\t    for (let i = 0; i < n; i++)\n\t\tfor (let j = 0; j < n; j++) {\n\t\t    if (M[i][k] + M[k][j] < M[i][j])\n\t\t\tMp[i][j] = Mp[i][k].concat(Mp[k][j].slice(1));\n\t\t    M[i][j] = Math.min(M[i][j], M[i][k] + M[k][j]);\n\t\t}\n\t    Ms.push(cloneMatrix(M));\n\t    Mps.push(cloneMatrix(Mp));\n\t}\n\n\treturn [Ms, Mps];\n    }\n}\n\n\nclass BinaryTree extends Graph {\n    constructor() {\n        super(0, true);\n        this.neighbours = []\n    }\n\n    addVertex() {\n        const n = this.numVertices();\n        this.neighbours.push([null, null]);\n        return n;\n    }\n\n    numVertices() {\n        return this.neighbours.length;\n    }\n\n    setLeftChild(parent, child) {\n        this.neighbours[parent][0] = child;\n    }\n    \n    setRightChild(parent, child) {\n        this.neighbours[parent][1] = child;\n    }\n}\n\n\nclass GraphDrawingCanvas {\n    constructor(canvas) {\n        this._canvas = canvas;\n        this._ctx = canvas.getContext(\"2d\");\n        \n        // Set display size (css pixels).\n        this._canvas.style.width = canvas.width + \"px\";\n        this._canvas.style.height = canvas.height + \"px\";\n\n        // Set actual size in memory (scaled to account for extra pixel density).\n        const scale = window.devicePixelRatio;\n        canvas.width = canvas.width * scale;\n        canvas.height = canvas.height * scale;\n\n        // Normalize coordinate system to use css pixels.\n        this._ctx.scale(scale, scale);\n        this._scale = scale;\n    }\n\n    width() {\n        return this._canvas.width / this._scale;\n    }\n\n    height() {\n        return this._canvas.height / this._scale;\n    }\n\n    ctx() {\n        return this._ctx;\n    }\n\n    getBoundingClientRect() {\n        return this._canvas.getBoundingClientRect();\n    }\n\n    addEventListener(event, handler) {\n        this._canvas.addEventListener(event, handler);\n    }\n}\n\nclass GraphDrawing {\n    constructor(graph, canvas, width, height) {\n        if (width)\n            canvas.width = width;\n        if (height)\n            canvas.height = height;\n        \n        this.graph = graph;\n        \n        const n = graph.numVertices();\n        \n        this.vertexPosition = Array.from({length: n}, () => [0, 0]);\n        \n        this.vertexLabels = Array.from({length: n}, () => undefined);\n        this.vertexContent = Array.from({length: n}, () => undefined);\n        this.vertexCSS = Array.from({length: n}, () => undefined);\n        \n        this.edgeLabels = {}\n        this.edgeCSS = {}\n\n        if (graph.weighted)\n            this.setWeightLabels();\n\n        this.focusVertex = undefined;\n        this.focusEdge = undefined;\n        \n        this.selectedVertices = [];\n        this.selectedEdges = [];\n        this.singleSelectVertex = true;\n        this.singleSelectEdge = false;\n\n        if (canvas != undefined)\n            this.canvas = new GraphDrawingCanvas(canvas);\n\n        this.setCSS();\n    }\n\n    width() {\n        return this.canvas.width();\n    }\n\n    height() {\n        return this.canvas.height();\n    }\n    \n    numVertices() {\n        return this.graph.numVertices();\n    }\n\n    addVertex() {\n        const vertex = this.graph.addVertex();\n        this.vertexPosition.push([0, 0]);\n        this.vertexLabels.push(undefined);\n        this.vertexCSS.push(undefined);\n        return vertex;\n    }\n\n    setPosition(i, pos) {\n        this.vertexPosition[i] = pos;\n    }\n\n    getPosition(i) {\n        return this.vertexPosition[i];\n    }\n\n    circularArrangementPosition(cx, cy, r) {\n        const n = this.numVertices();\n        \n        function position(vertex) {\n            const alpha = Math.PI / 2 + vertex * (2*Math.PI / n);\n            const x = cx + r * Math.cos(alpha);\n            const y = cy - r * Math.sin(alpha);\n            return [x, y];\n        }\n        return [...Array(n).keys()].map(vertex => position(vertex));\n    }\n    \n    circularArrangement(cx, cy, r) {\n        this.vertexPosition = this.circularArrangementPosition(cx, cy, r);\n        this.draw();\n    }\n\n    latticeArrangementPosition(m, n, x0, y0, width, height) {\n        function position(vertex, m, n) {\n            const j = vertex % n;\n            const i = Math.floor(vertex / n);\n            const w = width / (n-1), h = height / (m-1);\n            const x = x0 + j * w;\n            const y = y0 + i * h;\n            return [x, y];\n        }\n        return [...Array(this.numVertices()).keys()].map(vertex => position(vertex, m, n));\n    }\n    \n    latticeArrangement(m, n, x0, y0, width, height) {\n        this.vertexPosition = this.latticeArrangementPosition(m, n, x0, y0, width, height);\n        this.draw();\n    }\n\n    treeCoordinates(treeNeighbours, root, xStart, yStart) {\n        // we arrange the tree recursively\n        // visited nodes during tree traversal\n        const visited = new Array(this.numVertices()).fill(false);\n        // maximal dept of a tree node\n        let maxDepth = 0;\n\n        const coords = new Array(this.numVertices());\n        // we draw the tree rooted at the given depth on a coordinate xStart\n        // and return the x coordinate where its next sibling on that depth should be\n        function positionRec(vertex, xStart, depth) {\n            if (vertex == null)\n                return xStart+1;\n            \n            visited[vertex] = true;\n            if (depth > maxDepth)\n                maxDepth = depth;\n            let x = xStart;\n            treeNeighbours[vertex].forEach(neighbour => {\n                x = positionRec(neighbour, x, depth+1);\n            });\n            \n            if (treeNeighbours[vertex].length == 0) {\n                coords[vertex] = [xStart, yStart + depth];\n                return xStart+1;\n            } else {\n                coords[vertex] = [(x + xStart - 1) / 2, yStart + depth];\n                return x;\n            }\n        }\n\n        const xEnd = positionRec(root, xStart, yStart) - 1;\n        return {visited: visited, coords: coords, xEnd: xEnd, yEnd: yStart + maxDepth};\n    }\n\n\n    treeArrangementPositionNeigbours(initialVertexPosition, root, treeNeighbours, x0, y0, width, height, reverse=false) {\n        // special case when root has no edges\n        if (treeNeighbours[root].filter(neighbour => neighbour != null).length == 0) {\n            const result = [...initialVertexPosition];\n            result[root] = [x0 + width/2, y0 + height/2];\n            return result;\n        }\n        \n        const xStart = 0;\n        const yStart = 0;\n        const coordinates = this.treeCoordinates(treeNeighbours, root, xStart, yStart);\n        \n        let dh = height / (coordinates.yEnd - yStart + 1);\n        let dw = width / (coordinates.xEnd - xStart + 1);\n        return initialVertexPosition.map((p, vertex) => {\n            if (!coordinates.visited[vertex])\n                return p;\n            else {\n                const [x, y] = coordinates.coords[vertex];\n                return [x0 + dw / 2 + x * dw, y0 + dh / 2 + y * dh];\n            }\n        });\n    }\n    \n    \n    treeArrangementPosition(initialVertexPosition, root, treeEdges, x0, y0, width, height, reverse=false) {\n        // build adjacency lists for the tree\n        const n = this.numVertices()\n        const treeNeighbours = Graph.adjacencyLists(n, treeEdges, reverse);\n        return this.treeArrangementPositionNeigbours(initialVertexPosition, root, treeNeighbours, x0, y0, width, height, reverse);\n    }\n\n    treeArrangement(root, treeEdges, x0, y0, width, height, reverse=false) {\n        this.vertexPosition = this.treeArrangementPosition(this.vertexPosition, root, treeEdges, x0, y0, width, height, reverse);\n        this.draw();\n    }\n\n    treeArrangementNeighbours(root, treeNeighbours, x0, y0, width, height, reverse=false) {\n        this.vertexPosition = this.treeArrangementPositionNeigbours(this.vertexPosition, root, treeNeighbours, x0, y0, width, height, reverse);\n        this.draw();\n    }\n    \n    forrestArrangementPosition(initialVertexPosition, roots, forestEdges, x0, y0, width, height, reverse=false) {\n        // build adjacency lists for the forest\n        const n = this.numVertices()\n        const forrestNeighbours = Graph.adjacencyLists(n, forestEdges, reverse);\n\n        let xStart = 0;\n        let xEnd = 0;\n        let yStart = 0;\n        let yEnd = 0;\n        const coordinates = {\n            visited: Array(n).fill(false),\n            coords: Array(n)\n        }\n        roots.forEach(root => {\n            const  c = this.treeCoordinates(forrestNeighbours, root, xStart, yStart);\n            for (let i = 0; i < n; i++) {\n                if (c.visited[i]) {\n                    coordinates.visited[i] = true;\n                    coordinates.coords[i] = c.coords[i];\n                }\n            }\n            xEnd = c.xEnd;\n            xStart = c.xEnd + 1;\n            yEnd = Math.max(yEnd, c.yEnd);\n        });\n\n        let dh = height / (yEnd + 1);\n        let dw = width / (xEnd  + 1);\n        return initialVertexPosition.map((p, vertex) => {\n            if (!coordinates.visited[vertex])\n                return p;\n            else {\n                const [x, y] = coordinates.coords[vertex];\n                return [x0 + dw / 2 + x * dw, y0 + dh / 2 + y * dh];\n            }\n        });\n    }\n\n    forrestArrangement(roots, forestEdges, x0, y0, width, height, reverse=false) {\n        this.vertexPosition = this.forrestArrangementPosition(this.vertexPosition, roots, forestEdges, x0, y0, width, height, reverse);\n        this.draw();\n    }\n    \n    shake(n) {\n        this.vertexPosition = this.vertexPosition.map(p => [p[0] + Math.random() * n - n/2, p[1] + Math.random() * n - n/2])\n    }\n\n    animateArrangement(newVertexPosition, n=30, dt=500) {\n        this.draw();\n        let t = 0;\n        const startVertexPosition = [...this.vertexPosition];\n        const self = this;\n        function step() {\n            for (let vertex = 0; vertex < self.numVertices(); vertex++) {\n                const [x0, y0] = startVertexPosition[vertex];\n                const [x1, y1] = newVertexPosition[vertex];\n                self.vertexPosition[vertex] = [(1-t)*x0 + t*x1, (1-t)*y0 + t*y1];\n            }\n            self.draw();\n            t += 1 / n;\n            if (t < 1)\n                setTimeout(step, dt/n);\n        }\n        setTimeout(step, dt);\n    }\n\n    // VERTEX CONTENT\n\n    getVertexContent(vertex) {\n        if (this.vertexContent[vertex] !== undefined) {\n            const str = this.vertexContent[vertex];\n            if (/^-?\\d+$/.test(str))\n                return parseInt(str);\n            else\n                return str;\n        } else\n            return vertex;\n    }\n\n    setVertexContent(vertex, content) {\n        if (this.vertexContent[vertex] === content)\n            return false;\n        this.vertexContent[vertex] = content;\n        this.draw();\n        return true;\n    }\n\n    // LABELS\n    \n    getVertexLabel(vertex) {\n        return this.vertexLabels[vertex];\n    }\n    \n    setVertexLabel(vertex, label) {\n        if (this.vertexLabels[vertex] == label)\n            return false;\n        this.vertexLabels[vertex] = label;\n        this.draw();\n        return true;\n    }\n\n    removeVertexLabel(vertex) {\n        return this.setVertexLabel(vertex, undefined);\n    }\n\n    removeAllVertexLabels() {\n        for (let vertex = 0; vertex < this.numVertices(); vertex++)\n            this.removeVertexLabel(vertex);\n    }\n\n    edgeKey(edge) {\n        return JSON.stringify(this.graph.normalizeEdge(edge));\n    }\n\n    getEdgeLabel(edge) {\n        return this.edgeLabels[this.edgeKey(edge)];\n    }\n\n    setEdgeLabel(edge, label) {\n        const key = this.edgeKey(edge);\n        if (this.edgeLabels[key] == label)\n            return false;\n        this.edgeLabels[key] = label;\n        this.draw();\n        return true;\n    }\n\n    removeEdgeLabel(edge) {\n        return this.setEdgeLabel(edge, undefined);\n    }\n\n    getLabeledVertices() {\n        const vertices = []\n        for (let vertex = 0; vertex < this.numVertices(); vertex++) {\n            if (this.vertexLabels[vertex] != undefined)\n                vertices.push(vertex);\n        }\n        return vertices;\n    }\n\n    numLabeledVertices() {\n        let vertices = 0;\n        for (let vertex = 0; vertex < this.numVertices(); vertex++) {\n            if (this.vertexLabels[vertex] != undefined)\n                vertices++;\n        }\n        return vertices;\n    }\n\n    vertexOrderByLabel() {\n        const labels = []\n        for (let vertex = 0; vertex < this.numVertices(); vertex++) {\n            const label = this.vertexLabels[vertex];\n            if (label != undefined)\n                labels.push([label, vertex]);\n            labels.sort((a, b) => a[0] - b[0]);\n        }\n        return labels.map(x => x[1]);\n    }\n\n    setWeightLabels() {\n        if (!this.graph.weighted)\n            return false;\n        const edges = this.graph.getWeightedEdges();\n        edges.forEach(edge => this.setEdgeLabel([edge[1], edge[2]], edge[0]));\n        return true;\n    }\n\n    \n    // CSS\n    getVertexCSS(vertex) {\n        return this.vertexCSS[vertex];\n    }\n\n    getVertexCSSProperty(vertex, property) {\n        const css = this.getVertexCSS(vertex);\n        if (css === undefined)\n            return undefined;\n        return css[property];\n    }\n\n    setVertexCSS(vertex, css) {\n        for (const property in css)\n            this.setVertexCSSProperty(vertex, property, css[property]);\n        this.draw();\n    }\n\n    setVertexCSSProperty(vertex, property, value) {\n        if (this.getVertexCSS(vertex, property) == value)\n            return false;\n        if (!this.vertexCSS[vertex])\n            this.vertexCSS[vertex] = {};\n        this.vertexCSS[vertex][property] = value;\n        this.draw();\n        return true;\n    }\n    \n    removeVertexCSS(vertex) {\n        if (this.getVertexCSS(vertex) == undefined)\n            return false;\n        delete this.vertexCSS[vertex];\n        this.draw();\n        return true;\n    }\n\n    removeAllVertexCSS() {\n        this.vertexCSS = Array(this.numVertices());\n        this.draw();\n    }\n\n    getEdgeCSS(edge) {\n        return this.edgeCSS[this.edgeKey(edge)];\n    }\n\n    getEdgeCSSProperty(edge, property) {\n        const css = this.getEdgeCSS(edge);\n        if (css === undefined)\n            return undefined;\n        return css[property];\n    }\n\n    setEdgeCSSProperty(edge, property, value) {\n        if (this.getEdgeCSSProperty(edge, property) == value)\n            return false;\n        const key = this.edgeKey(edge);\n        if (this.edgeCSS[key] == undefined)\n            this.edgeCSS[key] = {};\n        this.edgeCSS[key][property] = value;\n        this.draw();\n        return true;\n    }\n    \n    setEdgeCSS(edge, css) {\n        for (const property in css)\n            this.setEdgeCSSProperty(edge, property, css[property]);\n    }\n\n    removeEdgeCSS(edge) {\n        if (this.getEdgeCSS(edge) == undefined)\n            return false;\n        delete this.edgeCSS[this.edgeKey(edge)];\n        this.draw();\n        return true;\n    }\n\n    // set css to the vertex currently in focus\n    setFocusVertexCSS(css) {\n        if (this.focusVertex == undefined)\n            return false;\n        return this.setVertexCSS(this.focusVertex);\n    }\n    \n    // set css to the edge currently in focus\n    setFocusEdgeCSS(css) {\n        if (this.focusEdge == undefined)\n            return false;\n        return this.setEdgeCSS(this.focusEdge);\n    }\n\n    // reset both vertex and edge css styles\n    resetAllCSS() {\n        this.vertexCSS = Array(this.vertexCSS.length).fill(undefined);\n        this.edgeCSS = {};\n        this.draw();\n        return true;\n    }\n\n    // MOUSE POSITION\n    \n    // is point (x, y) close to the given vertex?\n    closeToVertex(vertex, x, y, eps = 15) {\n        const [xc, yc] = this.vertexPosition[vertex];\n        return (x - xc)*(x - xc) + (y - yc)*(y - yc) <= eps * eps;\n    }\n\n    // which node lies on point (x, y)\n    vertexOn(x, y) {\n        const n = this.numVertices();\n        for (let vertex = 0; vertex < n; vertex++)\n            if (this.closeToVertex(vertex, x, y))\n                return vertex;\n        return undefined;\n    }\n\n    // is point (x, y) close to the given edge [vertex1, vertex2]?\n\n    // is point (x, y) close to the given edge [vertex1, vertex2]?\n    closeToEdge(edge, x, y, curvature=0) {\n        if (curvature == 0) {\n            var [vertex1, vertex2] = edge;\n            var [x0, y0] = this.vertexPosition[vertex1];\n            var [x1, y1] = this.vertexPosition[vertex2];\n            \n            function distance(ax, ay, bx, by) { \n                return Math.sqrt((ax - bx)*(ax - bx) + (ay - by)*(ay - by));\n            }\n            var eps = 1;\n            return Math.abs(distance(x, y, x0, y0) + distance(x, y, x1, y1) - distance(x0, y0, x1, y1)) < eps;\n        } else {\n            function pointOnQuadraticCurve(x, y, P0, P1, P2, eps = 1) {\n                function quadraticCurveEquation(t, P0, P1, P2) {\n                    const xT = (1 - t) ** 2 * P0[0] + 2 * (1 - t) * t * P1[0] + t ** 2 * P2[0];\n                    const yT = (1 - t) ** 2 * P0[1] + 2 * (1 - t) * t * P1[1] + t ** 2 * P2[1];\n                    return { x: xT, y: yT };\n                }\n                \n                const n = 50;\n                const dt = 1 / n;\n                let t = 0;\n                for (let i = 0; i <= n; i++) {\n                    t += dt;\n                    const { x: xT, y: yT } = quadraticCurveEquation(t, P0, P1, P2);\n                    const distance = Math.sqrt((xT - x) ** 2 + (yT - y) ** 2);\n                    if (distance < eps)\n                        return true;\n                }\n                \n                return false;\n            }\n            var [vertex1, vertex2] = edge;\n            var [x0, y0] = this.vertexPosition[vertex1];\n            var [x1, y1] = this.vertexPosition[vertex2];\n            var [mx, my] = [(x0 + x1) / 2, (y0 + y1) / 2];\n            return pointOnQuadraticCurve(x, y, [x0, y0], [mx - curvature*(my - y0), my + curvature*(mx - x0)], [x1, y1], 5);\n        }\n    }\n    \n    // which edge lies on point (x, y)\n    edgeOn(x, y) {\n        return this.graph.getEdges().find(edge => {\n            let curvature = this.getEdgeCSSProperty(edge, \"curvature\");\n            if (curvature == undefined) curvature = this.CSS.edge.curvature;\n            return this.closeToEdge(edge, x, y, curvature)\n        });\n    }\n\n    // FOCUSING\n\n    // focus vertex under the mouse pointer that is at (x, y)\n    focusVertexOn(x, y) {\n        const vertex = this.vertexOn(x, y);\n        if (vertex != this.focusVertex) {\n            this.focusEdge = undefined;\n            this.focusVertex = vertex;\n            this.draw();\n            return true;\n        }\n        return false;\n    }\n\n    // focus edge under the mouse pointer that is at (x, y)\n    focusEdgeOn(x, y) {\n        if (this.vertexOn(x, y) != undefined) {\n            if (!this.focusEdge)\n                return false;\n            \n            this.focusEdge = undefined;\n            return true;\n        }\n        const edge = this.edgeOn(x, y);\n        if (edge != this.focusEdge) {\n            this.focusEdge = edge;\n            this.draw();\n            return true;\n        }\n        return false;\n    }\n\n    // SELECTION\n\n    // check if the given vertex is selected\n    isSelectedVertex(vertex) {\n        return this.selectedVertices.includes(vertex)\n    }\n\n    // check if the given edge is selected\n    isSelectedEdge(edge) {\n        for (const e of this.selectedEdges)\n            if (Graph.equalEdges(e, edge))\n                return true;\n        return false;\n    }\n    \n    // select a given vertex\n    selectVertex(vertex) {\n        if (!this.isSelectedVertex(vertex)) {\n            if (this.singleSelectVertex)\n                this.selectedVertices = [];\n            this.selectedVertices.push(vertex);\n            this.draw();\n            return true;\n        }\n        return false;\n    }\n\n    // select a given edge\n    selectEdge(edge) {\n        if (!this.isSelectedEdge(edge)) {\n            if (this.singleSelectEdge)\n                this.selectedEdges = [];\n            this.selectedEdges.push(edge);\n            this.draw();\n            return true;\n        }\n        return false;\n    }\n\n    // select vertex on given position\n    selectVertexOn(x, y) {\n        const vertex = this.vertexOn(x, y);\n        if (vertex == undefined)\n            return false;\n        return this.selectVertex(vertex);\n    }\n\n    // select edge on given position\n    selectEdgeOn(x, y) {\n        if (this.vertexOn(x, y) != undefined)\n            return false;\n        const edge = this.edgeOn(x, y);\n        if (edge == undefined)\n            return false;\n        return this.selectEdge(edge);\n    }\n\n    // select vertex currently in focus\n    selectFocusVertex() {\n        if (this.focusVertex)\n            return this.selectVertex(this.focusVertex);\n        return false;\n    }\n\n    // select edge currently in focus\n    selectFocusEdge() {\n        if (this.focusEdge)\n            return this.selectEdge(this.focusEdge);\n        return false;\n    }\n    \n    // deselect a given vertex\n    deselectVertex(vertex) {\n        if (this.isSelectedVertex(vertex)) {\n            this.selectedVertices = this.selectedVertices.filter(v => v !== vertex);\n            this.draw();\n            return true;\n        }\n        return false;\n    }\n\n    // deselect a given edge\n    deselectEdge(edge) {\n        if (this.isSelectedEdge(edge)) {\n\t    this.selectedEdges = this.selectedEdges.filter(e => !Graph.equalEdges(e, edge));\n            this.draw();\n            return true;\n        }\n        return false;\n    }\n    \n    // deselect vertex currently in focus\n    deselectFocusVertex() {\n        if (this.focusVertex)\n            return this.deselectVertex(this.focusVertex);\n        return false;\n    }\n\n    // deselect edge currently in focus\n    deselectFocusEdge() {\n        if (this.focusEdge)\n            return this.deselectEdge(this.focusEdge);\n        return false;\n    }\n\n    \n    // deselect all vertices\n    deselectAllVertices() {\n        if (this.selectedVertices != []) {\n            this.selectedVertices = [];\n            this.draw();\n            return true;\n        }\n        return false;\n    }\n\n    // deselect all edges\n    deselectAllEdges() {\n        if (this.selectedEdges != []) {\n            this.selectedEdges = [];\n            this.draw();\n            return true;\n        }\n        return false;\n    }\n\n    // deselect all vertices and edges\n    deselectAll() {\n        let change = false;\n        change = change || this.deselectAllVertices();\n        change = change || this.deselectAllEdges();\n        return change;\n    }    \n\n    // deselect vertex on the given mouse position (x, y)\n    deselectVertexOn(x, y) {\n        const vertex = this.vertexOn(x, y);\n        if (vertex == undefined)\n            return false;\n        return this.deselectVertex(vertex);\n    }\n\n    // deselect edge on the given mouse position (x, y)\n    deselectEdgeOn(x, y) {\n        const edge = this.edgeOn(x, y);\n        if (edge == undefined)\n            return false;\n        return this.deselectEdge(edge);\n    }\n    \n    // toggle selection of a given vertex\n    toggleSelectVertex(vertex) {\n        if (this.isSelectedVertex(vertex))\n            this.deselectVertex(vertex);\n        else\n            this.selectVertex(vertex);\n    }\n\n    // toggle selection of a given edge\n    toggleSelectEdge(edge) {\n        if (this.isSelectedEdge(edge))\n            this.deselectEdge(edge);\n        else\n            this.selectEdge(edge);\n    }\n\n    // toggle selection of a vertex on the given coordinates (x, y)\n    toggleSelectVertexOn(x, y) {\n        const vertex = this.vertexOn(x, y);\n        if (vertex == undefined)\n            return false;\n        this.toggleSelectVertex(vertex);\n        return true;\n    }\n\n    // toggle selection of an edge on the given coordinates (x, y)\n    toggleSelectEdgeOn(x, y) {\n        if (this.vertexOn(x, y) != undefined)\n            return false;\n        \n        const edge = this.edgeOn(x, y);\n        if (edge == undefined)\n            return false;\n        this.toggleSelectEdge(edge);\n        return true;\n    }\n\n    \n    // MOVING VERTICES\n\n    // moves focused vertex to position (x, y)\n    moveFocusVertex(x, y) {\n        if (this.focusVertex != undefined) {\n            this.vertexPosition[this.focusVertex] = [x, y];\n            this.draw();\n            return true;\n        }\n        return false;\n    }\n\n    // move selectedVertices to (x, y)\n    moveSelectedVertices(x, y) {\n        this.selectedVertices.forEach((vertex) => {\n            this.vertexPosition[vertex] = [x, y];\n        });\n        this.draw();\n    }\n\n    // move selected vertices by (dx, dy)\n    moveSelectedVerticesBy(dx, dy) {\n        this.selectedVertices.forEach((vertex) => {\n            const [x, y] = this.vertexPosition[vertex];\n            this.vertexPosition[vertex] = [x + dx, y + dy];\n        });\n        this.draw();\n    }\n\n    // graph drawing\n    draw() {\n        if (this.canvas == undefined)\n            return;\n        \n        function drawEdgeLine(ctx, x1, y1, x2, y2, width, color, directed, label, curvature, vertexSize1, vertexSize2) {\n            var d = Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));\n            \n            ctx.save();\n            ctx.translate(x2, y2);\n            var alpha = Math.atan2(y2 - y1, x2 - x1);\n            ctx.rotate(alpha);\n\n            var bottomX = -d, bottomY = 0;\n            var topX = 0, topY = 0;\n\n            // draw \"line\"\n            ctx.beginPath();\n            ctx.lineWidth = width;\n            ctx.strokeStyle = color;\n            ctx.moveTo(bottomX, bottomY);\n            const midX = (bottomX + topX) / 2;\n            const midY = -curvature * midX;\n            ctx.quadraticCurveTo(midX, midY, topX, topY);\n            ctx.stroke();\n\n            // draw \"arrow\"\n            if (directed) {\n                if (curvature != 0) {\n                    ctx.save();\n                    const Cx = t => bottomX*(1-t)**2 + 2*midX*t*(1-t) + topX*t**2;\n                    const Cy = t => bottomY*(1-t)**2 + 2*midY*t*(1-t) + topY*t**2;\n                    const n = 200;\n                    const dt = 1/n;\n                    let t = 1.0;\n                    for (let i = 0; i <= n; i++) {\n                        t -= dt;\n                        if ((Cx(t) - topX)**2 + (Cy(t) - topY)**2 > vertexSize2**2)\n                            break;\n                    }\n\n                    const alpha = Math.atan2(Cy(t + dt) - Cy(t), Cx(t + dt) - Cx(t));\n                    ctx.rotate(alpha);\n                }\n\n                ctx.beginPath();\n                const length = 15;\n                ctx.moveTo(topX - vertexSize2 - length, topY - length / 3);\n                ctx.lineTo(topX - vertexSize2, topY);\n                ctx.stroke();\n                \n                ctx.beginPath();\n                ctx.moveTo(topX - length - vertexSize2, topY + length / 3);\n                ctx.lineTo(topX - vertexSize2, topY);\n                ctx.stroke();\n\n                if (curvature != 0)\n                    ctx.restore();\n            }\n\n            // print weight\n            if (label !== undefined) {\n                ctx.font = \"15px Arial\";\n                ctx.translate((bottomX + topX) / 2, (bottomY + topY) / 2);\n                ctx.rotate(-alpha);\n                ctx.beginPath();\n                ctx.arc(0, 0, 2, 0, 2*Math.PI);\n                ctx.fill();\n\t\tctx.textAlign = \"center\";\n\t\tctx.textBaseline = \"middle\";\n                ctx.fillText(label, 10, 10);\n            }\n            \n            ctx.restore();\n        }\n\n        function drawEdgeLoop(ctx, x, y, width, color, label) {\n            ctx.beginPath();\n            ctx.ellipse(x, y - 10, 10, 15, Math.PI, 0, 2*Math.PI);\n            ctx.stroke();\n        }\n\n        function drawVertexCircle(ctx, x, y, size, color, fontFamily, fontSize, content, label, labelSize, labelColor, labelBackground) {\n            ctx.beginPath();\n            ctx.arc(x, y, size, 0, 2 * Math.PI);\n            ctx.fillStyle = color;\n            ctx.fill();\n            ctx.lineWidth = 1;\n            ctx.stroke();\n            ctx.font = fontSize + \" \" + fontFamily;\n            ctx.fillStyle = (0,_colors_js__WEBPACK_IMPORTED_MODULE_0__.hsvColor)(color).v >= 0.6 ? \"black\" : \"white\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillText(content, x, y);\n            if (label !== undefined) {\n                ctx.save();\n                ctx.font = labelSize + \" \" + fontFamily;\n                ctx.fillStyle = labelColor;\n\n                const x0 = x + 25, y0 = y - 15;\n\n                if (labelBackground) {\n                    const padding = 2;\n                    const textWidth = ctx.measureText(label).width + padding + 2;\n                    const textHeight = parseInt(labelSize) + padding;\n                    ctx.globalAlpha = 0.8;\n                    ctx.fillStyle = \"#ddd\";\n                    ctx.fillRect(x0 - textWidth / 2, y0 - textHeight / 2, textWidth, textHeight);\n                    ctx.globalAlpha = 1;\n                    ctx.strokeStyle = labelColor;\n                    ctx.strokeRect(x0 - textWidth / 2, y0 - textHeight / 2, textWidth, textHeight);\n                }\n                \n                ctx.fillStyle = labelColor;\n                ctx.fillText(label, x0, y0);\n\t\tctx.restore();\n            }\n        }\n\n        const self = this;\n        function drawEdge(ctx, edge, css, vertexCSS1, vertexCSS2) {\n            const [vertex1, vertex2] = edge;\n            if (css == undefined)\n                css = self.CSS.edge;\n            if (vertexCSS1 == undefined)\n                vertexCSS1 = self.CSS.vertex;\n            if (vertexCSS2 == undefined)\n                vertexCSS2 = self.CSS.vertex;\n            \n\t    const width = \"width\" in css ? css.width : self.CSS.edge.width;\n\t    const color = \"color\" in css ? css.color : self.CSS.edge.color;\n\t    const curvature = \"curvature\" in css ? css.curvature : self.CSS.edge.curvature;\n            \n            if (vertex1 != vertex2) {\n                const [x1, y1] = self.vertexPosition[vertex1];\n                const [x2, y2] = self.vertexPosition[vertex2];\n                const label = self.getEdgeLabel(edge);\n                const vertexSize1 = \"size\" in vertexCSS1 ? vertexCSS1[\"size\"] : self.CSS.vertex.size;\n                const vertexSize2 = \"size\" in vertexCSS2 ? vertexCSS1[\"size\"] : self.CSS.vertex.size;\n                \n                drawEdgeLine(ctx, x1, y1, x2, y2, width, color, self.graph.directed, label, curvature, vertexSize1, vertexSize2);\n            } else {\n                const [x, y] = self.vertexPosition[vertex1];\n                const label = self.getEdgeLabel(edge);\n                const vertexSize =  \"size\" in vertexCSS1 ? vertexCSS1[\"size\"] : self.CSS.vertex.size;\n                drawEdgeLoop(ctx, x, y, width, color, label, vertexSize);\n            }\n        }\n\n        function drawVertex(ctx, vertex, css) {\n            if (css == undefined)\n                css = self.CSS.vertex;\n            const [x, y] = self.vertexPosition[vertex];\n\t    const color = \"color\" in css ? css.color : self.CSS.vertex.color;\n\t    const size = \"size\" in css ? css.size : self.CSS.vertex.size;\n            const fontFamily = \"fontFamily\" in css ? css.fontFamily : self.CSS.vertex.fontFamily;\n            const fontSize = \"fontSize\" in css ? css.fontSize : self.CSS.vertex.fontSize;\n            const label = self.vertexLabels[vertex];\n            const content = self.getVertexContent(vertex);\n            const labelSize = \"labelSize\" in css ? css.labelSize : self.CSS.vertex.labelSize;\n            const labelColor = \"labelColor\" in css ? css.labelColor : self.CSS.vertex.labelColor;\n            const labelBackground = \"labelBackground\" in css ? css.labelBackground : self.CSS.vertex.labelBackground;\n            \n            drawVertexCircle(ctx, x, y, size, color, fontFamily, fontSize, content, label, labelSize, labelColor, labelBackground);\n        }\n\n        const ctx = this.canvas.ctx();\n        ctx.clearRect(0, 0, this.canvas.width(), this.canvas.height());\n\n        // draw edges that are not in focus\n        this.graph.getEdges().forEach(edge => {\n            if (!Graph.equalEdges(this.focusEdge, edge)) {\n                const edgeCSS = this.getEdgeCSS(edge);\n                const [v1, v2] = edge;\n                const vertexCSS1 = this.getVertexCSS(v1);\n                const vertexCSS2 = this.getVertexCSS(v2);\n                drawEdge(ctx, edge, edgeCSS, vertexCSS1, vertexCSS2);\n            }\n        });\n\n        // draw focus edge\n        if (this.focusEdge != undefined) {\n            const css = {...this.getEdgeCSS(this.focusEdge)};\n            for (const property in this.CSS.focusEdge)\n                css[property] = this.CSS.focusEdge[property];\n            const [v1, v2] = this.focusEdge;\n            const vertexCSS1 = this.getVertexCSS(v1);\n            const vertexCSS2 = this.getVertexCSS(v2);\n            drawEdge(ctx, this.focusEdge, css, vertexCSS1, vertexCSS2);\n        }\n        \n        // draw vertices that are not in focus\n        for (let vertex = 0; vertex < this.numVertices(); vertex++)\n            if (vertex != this.focusVertex) {\n                const css = this.vertexCSS[vertex] ? this.vertexCSS[vertex] : this.CSS.vertex;\n                drawVertex(ctx, vertex, css);\n            }\n        \n        // draw focus vertex\n        if (this.focusVertex != undefined) {\n            const css = {...this.getVertexCSS(this.focusVertex)};\n            for (const property in this.CSS.focusVertex)\n                css[property] = this.CSS.focusVertex[property];\n            drawVertex(ctx, this.focusVertex, css);\n        }\n        \n        // draw selected vertices\n        this.selectedVertices.forEach(vertex => {\n            const css = {...this.getVertexCSS(vertex)};\n            for (const property in this.CSS.selectedVertex)\n                css[property] = this.CSS.selectVertex[property];\n            drawVertex(ctx, vertex, css)\n        });\n\n        // draw selected edges\n        this.selectedEdges.forEach(edge => {\n            const css = {...this.getEdgeCSS(edge)};\n            for (const property in this.CSS.selectedEdge)\n                css[property] = this.CSS.selectedEdge[property];\n            drawEdge(ctx, edge, css);\n        });\n    }\n\n    onVertexEvent(event, handler) {\n        const self = this;\n        this.canvas.addEventListener(event, function(e) {\n            const vertex = self.vertexOn(e.offsetX, e.offsetY);\n            if (vertex != undefined)\n                handler(vertex, e);\n        });\n    }\n\n    onVertexClick(handler) {\n        this.onVertexEvent(\"click\", handler);\n    }\n\n    onVertexDblClick(handler) {\n        this.onVertexEvent(\"dblclick\", handler);\n    }\n\n    onEdgeEvent(event, handler) {\n        const self = this;\n        this.canvas.addEventListener(event, function(e) {\n            const edge = self.edgeOn(e.offsetX, e.offsetY);\n            if (edge != undefined)\n                handler(edge);\n        });\n    }\n\n    onEdgeClick(handler) {\n        this.onEdgeEvent(\"click\", handler);\n    }\n\n    onEdgeDblClick(handler) {\n        this.onEdgeEvent(\"dblclick\", handler);\n    }\n\n    selectVerticesOnClick() {\n        var self = this;\n        this.onVertexClick(function(vertex) {\n            self.toggleSelectVertex(vertex);\n        });\n    }\n\n    selectEdgesOnClick() {\n        const self = this;\n        this.onEdgeClick(function(edge) {\n            self.toggleSelectEdge(edge);\n        });\n    }\n\n    selectVerticesOnDblClick() {\n        const self = this;\n        this.onVertexDblClick(function(vertex) {\n            self.toggleSelectVertex(vertex);\n        });\n    }\n\n    selectEdgesOnDblClick() {\n        const self = this;\n        this.onEdgeDblClick(function(edge) {\n            self.toggleSelectEdge(edge);\n        });\n    }\n\n    showFocusVertex() {\n        const self = this;\n        this.canvas.addEventListener(\"mousemove\", function(e) {\n            self.focusVertexOn(e.offsetX, e.offsetY);\n        });\n    }\n\n    showFocusEdge() {\n        const self = this;\n        this.canvas.addEventListener(\"mousemove\", function(e) {\n            self.focusEdgeOn(e.offsetX, e.offsetY);\n        });\n    }\n\n    dragFocusVertex() {\n        const self = this;\n        let mouseDown = false;\n        let downTime;\n        this.canvas.addEventListener(\"mousedown\", function(e) {\n            if (e.button == 0) {\n                mouseDown = true;\n                downTime = Date.now();\n            }\n        });\n        \n        this.canvas.addEventListener(\"mousemove\", function(e) {\n            if (mouseDown && Date.now() - downTime > 100)\n                self.moveFocusVertex(e.offsetX, e.offsetY);\n        });\n\n        this.canvas.addEventListener(\"mouseup\", function(e) {\n            mouseDown = false;\n        });\n    }\n\n    orderVerticesDblClick(start=0) {\n        const self = this;\n        this.onVertexDblClick(function(vertex) {\n            if (self.getVertexLabel(vertex) == undefined)\n                self.setVertexLabel(vertex, self.numLabeledVertices() + start);\n            else if (self.getVertexLabel(vertex) == self.numLabeledVertices() + start - 1) {\n                self.removeVertexLabel(vertex);\n            }\n        });\n    }\n\n    editValueOnClick() {\n        const self = this;\n        this.onVertexClick(function(vertex) {\n            const input = document.createElement(\"input\");\n            input.type = \"text\";\n            input.style.position = 'fixed';\n            const [x, y] = self.vertexPosition[vertex];\n            const canvasRect = self.canvas.getBoundingClientRect();\n            input.style.textAlign = \"center\";\n            input.style.width = 30 + \"px\";\n            input.style.height = 20 + \"px\";\n            input.style.left = canvasRect.left + x - 18 + 'px';\n            input.style.top = canvasRect.top + y - 12 + 'px';\n            document.body.appendChild(input);\n            input.focus();\n            input.onblur = function() {\n                self.setVertexContent(vertex, input.value);\n                document.body.removeChild(input);\n            }\n        });\n    }\n\n    setCSS() {\n        this.CSS = {\n            edge: {\n                width: 1,\n                color: \"black\",\n                curvature: 0\n            },\n            \n            vertex: {\n                color: \"white\",\n                size: 15,\n                fontFamily: \"Arial\",\n                fontSize: \"15px\",\n                labelSize: \"13px\",\n                labelColor: \"black\",\n                labelBackground: false\n            },\n\n            focusEdge: {\n                color: \"#bbbbbb\"\n            },\n\n            focusVertex: {\n                color: \"#cccccc\"\n            },\n            \n            selectedVertex: {\n                color: \"#9999ff\"\n            },\n\n            selectedEdge: {\n                width: 2,\n                color: \"red\"\n            }\n        }\n    }\n}\n\nclass CommandSetEdgeCSS {\n    constructor(graphDrawing, edge, css) {\n        this.graphDrawing = graphDrawing;\n        this.edge = edge;\n        this.css = css;\n    }\n\n    doCommand() {\n        this.undo = {...this.graphDrawing.getEdgeCSS(this.edge)};\n        this.graphDrawing.setEdgeCSS(this.edge, this.css);\n    }\n\n    undoCommand() {\n        this.graphDrawing.removeEdgeCSS(this.edge);\n        if (this.undo != undefined)\n            this.graphDrawing.setEdgeCSS(this.edge, this.undo);\n    }\n}\n\nclass CommandResetAllVertexCSS {\n    constructor(graphDrawing) {\n        this.graphDrawing = graphDrawing;\n    }\n\n    doCommand() {\n        this.undo = new Array(this.graphDrawing.numVertices());\n        for (let v = 0; v < this.graphDrawing.numVertices(); v++) {\n            this.undo[v] = this.graphDrawing.getVertexCSS(v);\n            this.graphDrawing.removeVertexCSS(v);\n        }\n    }\n\n    undoCommand() {\n        for (let v = 0; v < this.graphDrawing.numVertices(); v++)\n            this.graphDrawing.setVertexCSS(v, this.undo[v]);\n    }\n}\n\nclass CommandSetVertexCSS {\n    constructor(graphDrawing, vertex, css) {\n        this.graphDrawing = graphDrawing;\n        this.vertex = vertex;\n        this.css = css;\n    }\n\n    doCommand() {\n        this.undo = {...this.graphDrawing.getVertexCSS(this.vertex)};\n        this.graphDrawing.setVertexCSS(this.vertex, this.css);\n    }\n\n    undoCommand() {\n        this.graphDrawing.removeVertexCSS(this.vertex);\n        this.graphDrawing.setVertexCSS(this.vertex, this.undo);\n    }\n}\n\nclass CommandSetVertexLabel {\n    constructor(graphDrawing, vertex, label) {\n        this.graphDrawing = graphDrawing;\n        this.vertex = vertex;\n        this.label = label;\n    }\n\n    doCommand() {\n        this.undo = this.graphDrawing.getVertexLabel(this.vertex);\n        this.graphDrawing.setVertexLabel(this.vertex, this.label);\n    }\n\n    undoCommand() {\n        this.graphDrawing.setVertexLabel(this.vertex, this.undo);\n    }\n}\n\nclass CommandSetVertexContent {\n    constructor(graphDrawing, vertex, content) {\n        this.graphDrawing = graphDrawing;\n        this.vertex = vertex;\n        this.content = content;\n    }\n\n    doCommand() {\n        this.undo = this.graphDrawing.getVertexContent(this.vertex);\n        this.graphDrawing.setVertexContent(this.vertex, this.content);\n    }\n\n    undoCommand() {\n        this.graphDrawing.setVertexContent(this.vertex, this.undo);\n    }\n}\n\n\n\nclass GraphCommands extends _commands_js__WEBPACK_IMPORTED_MODULE_3__.Commands {\n    constructor(commands) {\n        super(commands);\n    }\n}\n\n\n//# sourceURL=webpack://algoedu.js/./components/graph.js?");

/***/ }),

/***/ "./components/union_find.js":
/*!**********************************!*\
  !*** ./components/union_find.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UnionFind\": () => (/* binding */ UnionFind)\n/* harmony export */ });\n// Union-Find data structure implementation\nclass UnionFind {\n    constructor(size) {\n        this.parent = Array(size).fill().map((_, index) => index);\n    }\n\n    find(node) {\n        if (this.parent[node] === node)\n            return node;\n        this.parent[node] = this.find(this.parent[node]);\n        return this.parent[node];\n    }\n\n    union(nodeA, nodeB) {\n        const rootA = this.find(nodeA);\n        const rootB = this.find(nodeB);\n        if (rootA !== rootB) {\n            this.parent[rootA] = rootB;\n            return true; // Nodes were merged\n        }\n        return false; // Nodes were already connected\n    }\n}\n\n\n//# sourceURL=webpack://algoedu.js/./components/union_find.js?");

/***/ }),

/***/ "./components/util.js":
/*!****************************!*\
  !*** ./components/util.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"shuffle\": () => (/* binding */ shuffle)\n/* harmony export */ });\nfunction shuffle(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n}\n\n\n//# sourceURL=webpack://algoedu.js/./components/util.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./components/graph.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});